# 2009
![1731925161977](https://github.com/user-attachments/assets/eb53e6f5-10d3-49f6-89f0-4da2ec919fc2)

(1)
 
  $4KB=2^{12}B$ 前四位为页号。

   $2362H:10ns+100ns+100ns=210ns$

   $1565H:10ns+100ns+10^8ns+10ns+100ns=220ns+10^8ns$

   $25A5H:10ns+100ns=110ns$

(2)

101565H

# 2010
![1731926076746](https://github.com/user-attachments/assets/fb5cff15-c9b7-4a0f-950d-4acbdc4fe1b4)

(1)

$1KB->2^{10}B$,页内10B，17CAH->5，虚拟页号为5

(2)
  FIFO替换第0页，1FCAH
(3)
  0BCAH,当前访问为置为零，访问下一个。
# 2011
![1731926838565](https://github.com/user-attachments/assets/d561944b-00c8-4887-b499-08711450686a)

（1）
	$16MB->2^{24}B$,24位, $4KB->2^{12}B$ ,12位页内地址，12位页号。 $1MB=2^{20}B$ ,12位页内，8位页框号，
 
（2）
	标记，行号，字块内地址。行内地址 $32B=2^5B$ 5位(最后)，8行->3位(中间)，标记->20-5-3=12(最初)。
 
(3)
	在，OO1->04,04C60H,未命中，标记前八位没有04。
 
(4)
	TLB同cache,BAC页内，00000010010 0->组号0，标记012，在主存中。
 # 2012
 ![1731928208836](https://github.com/user-attachments/assets/095870fd-bdd8-466c-8d66-6105632330cd)
 
 (1)
	21
 
(2)
	32
 
(3)
	41
 
(4)
	合适。 理由：如果程序的时间局部性越好， 那么从空闲页框链表中重新取回的机会越大，该策略的优势越明显。
# 2013
![1731928611545](https://github.com/user-attachments/assets/5364990f-8d09-464e-adcc-3b82e803ea69)
(1)

 页大小 $2^{12}B$ ,页表最大占用: $2^{20}*4B=4MB$

(2)

 页目录号:(((unsigned int)(LA))>>22)

 也表索引:(((unsigned int)(LA))>>12)

(3)

 长度8KB->两页，4KB一页,两页逻辑地址分别是:0000 8000H,0000 9000H;

 一个页表项4B, $0020 0000+4*8=0020 0020H ,0020 0020+4=0020 0024H$ ,页框号：00200H，0090 0000H，0090 1000H。
 # 2014
 ![1731931599780](https://github.com/user-attachments/assets/f39e39f4-54e0-4156-a67e-8ed0eb8582ea)

(1)

1000

(2)	

$容量=16 * 32B=2^{9}B$,块内偏移5位，行号4位，chache命中率1/1000 * 6=99.98%

(3)

第四条，第三条，读磁盘次，读TLB1001次。
 
# 2015

![1731932317642](https://github.com/user-attachments/assets/70e99f63-aabb-4670-b5e3-96b60f036751)

(1)

页和页框大小均为 $2^{12}B$ ,虚拟空间大小 $2^{20}$ 页

(2)

$(2^{10}*4B+2^{20}*4B)/2^{12}B=1+1024=1025页$

(3)

一个，高十位相同，属于同一个二级页表
# 2016

![1731932992096](https://github.com/user-attachments/assets/08ef7338-254a-4f8c-9364-1c03b590c4b5)

(1)

 
8KB->13位，A：32-13=19=B，D=13，C=24-13=11,64B->6=G,E+F=24-6=18,64KB/64B/2=9->F,E=18-9=9,H=9

(2)

 4099= $1*2^{12}+2+1$ =00 0001 0000 00 00 0011->3，00 0001 000B

(3)

缺页的开销大，要从外存调入。

(4)

存储快慢问题
# 2017
![1731935185130](https://github.com/user-attachments/assets/16c7df3e-ff47-4e08-bbb2-a55ab16a15c3)

(1)

占一页

(2)

00401->0000 0000 01 0000000001->都是第一项

(3)

运行态->阻塞态->就绪态->运行态，会
# 2018

![1731935724096](https://github.com/user-attachments/assets/2d675c2b-4091-44b5-a209-e498af1753f2)


(1)

主存物理地址占28位

(2)

全相联映射，SRAM

(3)

2路组相联，LRU位，脏位, $cache总容量=2^3*2^5*2B+2^3*2*(20+1+1+1)=512B+46B=558B$ ,看chache行信息是否有效

(4)

0040040H,未命中，有效位位0，后八位不变-> 011 0 0000->3组


![1731936597558](https://github.com/user-attachments/assets/79aa82b1-6871-4379-b0a8-6ec962cc44af)

(1)

0000 0001 1000 0000 0110 0000 0000 1000 =01806008H

(2)

物理地址PDBR(页目录基址地址寄存器)，会，不会

(3)

使用位和脏位
# 2019
![1731936998899](https://github.com/user-attachments/assets/1dbc7363-29bf-400d-b0a9-a05a35a6b0d7)

$4KB->2^{12}$ ,在同一页中，因为前五位都是00401，6位块内地址，64/4=16->4位组号，32-6-4=22位标志， 0000->0组
# 2020
![1731937798307](https://github.com/user-attachments/assets/63c2588e-c399-4b5e-a670-cf8385fc3d85)

(1)

1080 1000+2 * 4B=1080 1008H, 0001 0000 1000 0000 0001 ->66,1,0020 1000 + 66 * 4= (64+2) * 4 = 16 * 16 +8= 0020 1108H 00301 000H+ 001H * 4=00301 004H

(2)

虚拟必须连续，物理可以不连续

(3)

按行遍历好
# 2021
![1731939724331](https://github.com/user-attachments/assets/60e23bc2-f8d9-42a1-bae5-a0d82cbd217f)

(1)

4KB->12位，前18位虚页号，后12位页内地址

(2)

前18位中的高15位为标记，低三位为组号

(3)

4

(4)

32-30=2
