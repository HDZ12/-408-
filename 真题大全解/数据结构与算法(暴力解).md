# 2009
![1732870583001](https://github.com/user-attachments/assets/b907d2d9-cd87-422a-aff5-64ebff5d8a6a)

很明显的双指针，一个先走，一个k步之后再走，第一个到末尾，则就是倒数k个
```C
nt find_k(Linklist L, int k) {
    LNode *q, *r;
    r = L;
    q = L;
    int count = 0;
    while (r->next != NULL && count != k) {
        r = r->next;
        count += 1;
    }
    if (count != k)
        return 0;
    else
        while (r->next != NULL) {
            q = q->next;
            r = r->next;
        }
    printf("%d", q->data); 
    return 1;
}
```
# 2010
![1732871061078](https://github.com/user-attachments/assets/b9637cfe-789f-403a-b491-d2478d1de659)


暴力解法：构造一个新的数组，直接赋值。
空间复杂度: $O(n)$ ,时间复杂度：$O(n)$
```C
void remove_p(int a[], int p, int n) {
    int array[n];
    int i = p;
    int j = 0;
    for (i = p; i < n; i++) {
        array[j++] = a[i];
    }
    for (int k = 0; k < p; k++) {
        array[j++] = a[k];
    }
}
```
# 2011

![1732871620041](https://github.com/user-attachments/assets/910e6f1c-ba58-4b28-9340-a3071117daf2)

暴力解法：直接归并，取L/2的数值。时间复杂度 $O(n)$ ,空间复杂度 $O(n)$
```C
int merge(int A[], int m, int B[], int n) {
    int i = 0, j = 0, k = 0;
    int array[m + n];
    while (i < m && j < n) {
        if (A[i] <= B[j]) {
            array[k++] = A[i++];
        } else {
            array[k++] = B[j++];
        }
    }
    if (i != m) {
        while (i < m) { 
            array[k++] = A[i++];
        }
    }
    if (j != n) {
        while (j < n) {
            array[k++] = B[j++];
        }
    }
    return array[(m + n) / 2];
}
```
# 2012

![1732872495338](https://github.com/user-attachments/assets/3d3268ea-4b14-40a4-8777-4d568cc620bb)

暴力解法：思路同09年，大的长度减去小的长度，大的先走差值，然后双指针同时移动比较。时间复杂度： 
 $O(n)$ ,空间复杂度: $O(1)$
```C
LNode* find_common(linklist str1, linklist str2) {
    LNode *a, *b;
    if (str1.length > str2.length) {
        a = str1;
        b = str2;
    } else {
        a = str2;
        b = str1;
    }
    int m = a->length - b->length;
    int i = 0;
    while (i < m) {
        a = a->next;
        i++;
    }
    int j = 0;
    while (j < b->length && a != NULL && b != NULL) {
        if (a == b) {
            return a;
        }
        a = a->next;
        b = b->next;
        j++;
    }
    return NULL;
}
```

