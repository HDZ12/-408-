# 2009
![1732870583001](https://github.com/user-attachments/assets/b907d2d9-cd87-422a-aff5-64ebff5d8a6a)

很明显的双指针，一个先走，一个k步之后再走，第一个到末尾，则就是倒数k个
```C
nt find_k(Linklist L, int k) {
    LNode *q, *r;
    r = L;
    q = L;
    int count = 0;
    while (r->next != NULL && count != k) {
        r = r->next;
        count += 1;
    }
    if (count != k)
        return 0;
    else
        while (r->next != NULL) {
            q = q->next;
            r = r->next;
        }
    printf("%d", q->data); 
    return 1;
}
```
# 2010
![1732871061078](https://github.com/user-attachments/assets/b9637cfe-789f-403a-b491-d2478d1de659)


暴力解法：构造一个新的数组，直接赋值。
空间复杂度: $O(n)$ ,时间复杂度：$O(n)$
```C
void remove_p(int a[], int p, int n) {
    int array[n];
    int i = p;
    int j = 0;
    for (i = p; i < n; i++) {
        array[j++] = a[i];
    }
    for (int k = 0; k < p; k++) {
        array[j++] = a[k];
    }
}
```
# 2011

![1732871620041](https://github.com/user-attachments/assets/910e6f1c-ba58-4b28-9340-a3071117daf2)

暴力解法：直接归并，取L/2的数值。时间复杂度 $O(n)$ ,空间复杂度 $O(n)$
```C
int merge(int A[], int m, int B[], int n) {
    int i = 0, j = 0, k = 0;
    int array[m + n];
    while (i < m && j < n) {
        if (A[i] <= B[j]) {
            array[k++] = A[i++];
        } else {
            array[k++] = B[j++];
        }
    }
    if (i != m) {
        while (i < m) { 
            array[k++] = A[i++];
        }
    }
    if (j != n) {
        while (j < n) {
            array[k++] = B[j++];
        }
    }
    return array[(m + n) / 2];
}
```
# 2012

![1732872495338](https://github.com/user-attachments/assets/3d3268ea-4b14-40a4-8777-4d568cc620bb)

暴力解法：思路同09年，大的长度减去小的长度，大的先走差值，然后双指针同时移动比较。时间复杂度： 
 $O(n)$ ,空间复杂度: $O(1)$
```C
LNode* find_common(linklist str1, linklist str2) {
    LNode *a, *b;
    if (str1.length > str2.length) {
        a = str1;
        b = str2;
    } else {
        a = str2;
        b = str1;
    }
    int m = a->length - b->length;
    int i = 0;
    while (i < m) {
        a = a->next;
        i++;
    }
    int j = 0;
    while (j < b->length && a != NULL && b != NULL) {
        if (a == b) {
            return a;
        }
        a = a->next;
        b = b->next;
        j++;
    }
    return NULL;
}
```
# 2013

![1732886658414](https://github.com/user-attachments/assets/c4739640-0ae5-4c93-b6ec-a403d18a78b1)

暴力解法：两个思路，空间换时间，直接建立数组和n/2比较，直接快排，找中间元素

```C
void swap(int nums[], int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}

int partition(int nums[], int low, int high) {
    int i = low, j = high;
    while (i < j) {
        while (i < j && nums[j] > nums[low]) {
            j--;
        }
        while (i < j && nums[i] <= nums[low]) {
            i++;
        }
        if (i < j) {
            swap(nums, i, j);
        }
    }
    swap(nums, i, low);
    return i;
}

void quicksort(int nums[], int low, int high) {
    if (low < high) {
        int pivotpos = partition(nums, low, high);
        quicksort(nums, low, pivotpos - 1);
        quicksort(nums, pivotpos + 1, high);
    }
}

int find_majority_element(int a[], int n) {
    int candidate = a[n / 2];
    int count = 0;
    for (int i = 0; i < n; i++) {
        if (a[i] == candidate) {
            count++;
        }
    }
    return (count > n / 2) ? candidate : -1;
}

int main(int a[ ],int n) {
    quicksort(a, 0, n - 1);
    int result = find_majority_element(a, n);
    if (result != -1) {
        printf("主元素是: %d\n", result);
    } else {
        printf("没有主元素\n");
    }
    return 0;
}
```
# 2014
![1732888628522](https://github.com/user-attachments/assets/b8a95aba-5b17-4cc9-acfc-e735d900b596)

暴力解法：递归遍历，叶节点 * 权值相加；时间复杂度: $O(n)$ ,空间复杂度: $O(log n)$
```C
int calculate_wpl(BTnode root,int depth){
	if(root==NULL){
		return 0;
	}
	if(root->left==NULL&&root->right==NULL){
		return root->wight*depth;
	}
	return calculate_wpl(root->left,depth+1)+calculate_wpl(woot->right,depth+1);
}
```
# 2015

![1732890069414](https://github.com/user-attachments/assets/7a2dd8fd-0d95-4e7b-82a5-4b4c8967ac59)

暴力解法：双指针，一个正常遍历，一个在他后一个位置，每次遍历全表，一旦绝对值相等就删除节点，第一个节点走到末尾则结束遍历，时间复杂度: $O(n^2)$ ,空间复杂度: $O(1)$
```C
int abs(int n) {
    if (n > 0)
        return n;
    if (n < 0)
        return -n; 
    return 0; 
}

void remove_duplicates(LNode *head) { 
    LNode *p, *q, *r, *k;
    p = head->next;
    while (p != NULL && p->next != NULL) { 
        q = p->next;
        r = p;
        while (q != NULL) { 
            if (abs(q->data) == p->data) {
                k = q;
                q = q->next;
                r->next = q;
                free(k);
            } else {
                r = q; 
                q = q->next;
            }
        }
        p = p->next;
    }
}
```
