# 常考知识点
## 关于交换数据
1.进程之间不能直接交换数据，但可利用OS提供的共享文件(如管道)，信息传递系统，共享存储区进行通信

2.全局变量是针对一个进程而言的，不同的进程拥有不同的代码段和数据段，不能通过全局变量来交换进程之间的数据

3.临界资源一次只能为一个进程所用
## 关于进程的特性
1. 进程失去封闭性（进程执行的结果只取决于进程本身）后，不同速度下的执行结果不同
2. 进程被建立后，随着进程运行的正常或不正常结束而撤销
3. 进程不是一个完整的程序

进程是动态的，程序是静态的

进程是暂时的，程序是永久的

进程至少由代码，数据，pcb组成，程序仅需代码和数据

4.一个进程是程序在一个数据集上的一次运行过程；运行于不同的数据集，会形成不同的进程
## 进程与进程之间的关系
进程与进程之间是完全隔离的，线程与线程之间是没有隔离的，但并不意味着进程之间是毫无关联的
- 如一个进程的状态变化可能会引起另一个进程的状态变化
- 如打印机进程结束后可能会改变另一个等待打印机的进程
## 各种状态
1.死锁的进程是处于阻塞态的，不可能所有的进程都处于就绪态，但是可以所有的进程都处于阻塞态(死锁的时候）

2.就绪队列进程的多少与处理器的效率无关，只有当就绪队列为空时，CPU进入等待态，cpu效率下降
## 进程里的信息
C语言的程序在使用内存时有3个段

|      |           |                    |
| ---- | --------- | ------------------ |
|      | 存放什么？     | 举例                 |
| 正文段  | 存二进制代码，常量 | 全局赋值变量，常量值123      |
| 数据堆段 | 存动态分配的存储区 | 用malloc动态分配的存储区    |
| 数据栈段 | 存临时使用的变量  | 未赋值的局部变量，函数调用实参传递值 |
## 进程通信
利用共享文件进行的进程通信机制称为管道，管道即文件
# 进程的概念和特征
|           |                                                                                                                                                                    |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 定义        | - 进程是程序的一次执行过程<br>- 进程是一个程序及其数据在处理机上顺序执行时所发生的活动<br>- 进程是具有独立功能的程序在一个数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位                                                                 |
| 特征        | - 动态性；并发性；独立性；异步性                                                                                                                                                  |
| 为什么要引入进程？ | - 为了使多道程序并发执行，提高资源利用率和系统吞吐量<br>- 为了可以对并发执行的程序加以描述和控制                                                                                                               |
| 其他考点      | - 进程实体/进程映像 = PCB + 程序段 + 相关数据段<br>- 进程映像是静态的，进程是动态的，程序是静态的<br>- 进程控制块(PCB, Process Control Block)是进程的唯一标志<br>- 系统资源 = 处理机，存储器和其他设备服务于某个进程的"时间"【这里的系统资源类似于处理机的时间片】 |
# 进程的状态与转换
## 五种状态
| 运行态Running | 该时刻进程占用CPU                           |
|------------|--------------------------------------|
| 就绪态Ready   | 进程获得了除处理机外的一切所需资源，一旦得到处理机，就可以立即运行    |
| 阻塞态Blocked | 该进程正在等待某一事件发生而暂停运行，即使给他CPU控制权，它也无法运行 |
| 创建态New     | 进程正在被创建时的状态                          |
| 结束态Exit    | 进程正在从系统中消失时的状态                       |
## 状态转换图
## 状态的转换
| 就绪态-->运行态 | 1. 进程被调度，获得处理机资源（分派处理机时间片）【如系统将CPU分配给高优先权的进程】 |
|-----------|-----------------------------------------------|
| 运行态-->就绪态 | 1. 时间片用完后，不得不让出处理机                            |
|           | 2. 可剥夺的OS中，当有更高优先级的进程就绪时，调度程序将正在执行的进程转换为就绪态   |
| 运行态-->阻塞态 | 1. 进程请求某一资源（如外设） 的使用和分配时【如进程P申请临界资源】          |
|           | 2. 等待某一事件的发送时（如I/O操作的完成）【如进程P从磁盘读数据】          |
|           | 进程以系统调用的方式请求OS提供服务，这个过程系统从用户态转换为核心态         |
|           | 该过程是主动行为                                    |
| 阻塞态-->就绪态 | 1. I/O操作结束或中断结束时                              |
|           | 2. 发送了阻塞队列等待的事件，如发送了V操作，信号量+1，然后阻塞队列被唤醒到就绪队列中 |
|           | 该过程是被动行为，需要其他相关进程的协助                        |
## 进程的控制结构/数据结构
- 进程的控制结构 = PCB + 程序段 + 数据段
### PCB的组成
| 进程描述信息    | • 进程标识符PID：标识各个进程，每个进程都有一个并且唯一的标识符                    |
| --------- | ----------------------------------------------------- |
|           | • 用户标识符UID：进程归属的用户，用户标识符主要为共享和保护服务                    |
| 进程控制和管理信息 | • 进程当前状态，如 new、ready、running、waiting 或 blocked 等      |
|           | • 进程优先级：进程抢占 CPU 时的优先级                                |
| 资源分配清单    | • 有关内存地址空间或虚拟地址空间的信息                                  |
|           | • 所打开文件的列表和所使用的 I/O 设备信息                              |
| CPU 相关信息  | • CPU 中各个寄存器的值                                        |
|           | • 当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中以便进程重新执行时，能从断点处继续执行 |
|           |                                                       |
## 如何组织PCB
| 链接方式 | • 把统一状态的PCB链成一个队列，不同状态对应不同的队列     |
|------|-----------------------------------|
|      | • 也可把处于阻塞态的进程的PCB，根据阻塞原因，排成多个阻塞队列 |
| 索引方式 | • 将统一状态的进程组织在一个索引表中               |
|      | • 如就绪索引表，阻塞索引表                    |
## 程序段
- 能被进程调度程序调度到CPU执行的程序代码段
- 程序可以被多个进程共享，即多个进程可以运行同一个程序
## 数据段
- 可以是进程对应的程序加工处理的原始数据
- 可以是程序执行时产生的中间或最终结果
# 进程的控制
|     |                                                                                                                                                                                                                                                                           |                                                                |
| --- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------- |
| 创建  | - 允许一个进程创建另一个进程<br>- 允许子进程继承父进程所拥有的资源<br><br>- 创建进程的过程如下：<br><br>- 申请一个空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息，比如进程的唯一标识等；<br>- 为该进程分配运行时所必需的资源，比如内存资源；<br>- 将 PCB 插入到就绪队列，等待被调度运行；                                                                                                | 1. 终端登陆系统，作业调度<br>2. 系统提供服务<br>3. 用户程序的应用<br><br>设备分配不需要创建进程 |
| 终止  | - 有 3 种终止方式：正常结束、异常结束以及外界干预<br>- 当子进程被终止时，其在父进程处继承的资源应当还给父进程<br>- 当父进程被终止时，该父进程的子进程就变为孤儿进程<br><br>- 终止进程的过程如下：<br><br>- 查找需要终止的进程的 PCB；<br>- 如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；<br>- 如果其还有子进程，则应将该进程的子进程交给 1 号进程接管；<br>- 将该进程所拥有的全部资源都归还给操作系统；<br>- 将其从 PCB 所在队列中删除； | 1. 正常结束<br>2. 异常结束<br>3. 外界干预                                  |
| 阻塞  | - 当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待<br>- 一旦被阻塞等待，只能由另一个进程唤醒<br><br>- 阻塞进程的过程如下：<br><br>- 找到将要被阻塞进程标识号对应的 PCB；<br>- 如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行；<br>- 将该 PCB 插入到阻塞队列中去；                                                                                                | 1. 请求系统资源失败<br>2. 等待某种操作的完成<br>3. 新数据尚未到达或无新任务可做               |
| 唤醒  | - 进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成<br>- 处于阻塞状态的进程是绝对不可能叫醒自己<br>- 如果某进程正在等待 I/O 事件，需由别的进程发消息给它<br>- 只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它<br><br>- 唤醒进程的过程如下：<br><br>- 在该事件的阻塞队列中找到相应进程的 PCB；<br>- 将其从阻塞队列中移出，并置其状态为就绪状态；<br>- 把该 PCB 插入到就绪队列中，等待调度程序调度；                         | 1. 释放该I/O设备的进程<br>2. 提供数据的进程                                   |
## 进程的通信
### 低级通信
PV操作
### 高级通信
|        |                                                                                                      |
| ------ | ---------------------------------------------------------------------------------------------------- |
| 1、共享存储 | - 如共享内存，共享文件系统                                                                                       |
| 2、信息传递 | - 需要发送消息和接受信息两个原语                                                                                    |
| 3、管道通信 | - 需要满足的能力 = 互斥 + 同步 + 确定对方的存在<br>- 缓冲区只允许一边写入，另一边读出，所以管道只能采用半双工通信<br><br>- 利用共享文件进行的进程通信机制称为管道，管道即文件 |
# 进程的上下文切换
|          |                                                                                                                                                |
| -------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| 上下文      | 上下文是指某一时刻CPU寄存器和PC的内容；如寄存器值，用户和系统内核栈内容                                                                                                         |
| 进程上下文切换  | 上下文切换是指一个进程切换到另一个进程的过程                                                                                                                         |
| 上下文切换的实质 | 上下文切换实质是处理机从一个进程的运行转到另一个进程上运行，这个过程中，进程的运行环境产生了实质性的变化                                                                                           |
| 上下文切换的消耗 | 有些处理器提供多个寄存器组，上下文切换只需要简单改变当前寄存器组的指针，不需要用到磁盘和主存                                                                                                 |
| 上下文切换的场景 | 1. 某个进程时间片耗尽时<br>2. 进程在系统资源不足时，要等到资源满足后才可以运行<br>3. 进程通过sleep将自己主动挂起<br>4. 有优先级更高的进程运行时<br>5. 发送硬件中断时                                           |
| 上下文切换的流程 | 1. 挂起一个进程，保存CPU上下文，包括PC和其他寄存器<br>2. 更新PCB信息<br>3. 把进程的PCB移到相应的队列（如就绪队列，阻塞队列）<br>4. 加载另一个进程执行，更新其PCB<br>5. 跳转到新进程PCB中的PC所指向的位置执行<br>6. 恢复处理机上下文 |
|          |                                                                                                                                                |
| 调度和切换的区别 | 先有资源的调度，才有进程的切换<br>\|调度\|- 决定资源分配给哪个进程的行为；是一种决策行为\|<br>\|切换\|- 实际分配的行为；是一种执行行为\|                                                               |
# 线程
|            |                                                                                                               |
| ---------- | ------------------------------------------------------------------------------------------------------------- |
| 关于线程的特征    | 1.线程是处理机调度的基本单位，可以独立执行程序<br><br>2.没有相同的进程，但是调用在不同进程中的线程可以相同                                                   |
| 关于线程可共享的东西 | 1.线程没有自己独立的地址空间，每个线程只拥有自己的独立的栈空间  <br>2.线程之间可以共享进程的资源(如代码段，堆空间，数据段，打开的文件)<br><br>3.进程之间不能共享虚拟地址空间，线程之间不能共享栈指针 |
| 线程的并行与并发   | 1.同一进程或不同进程内的线程都可以并发执行<br><br>2.进程之间可以并发但不可以并行，同一进程之间的线程可以并行                                                  |
| 其他         | 1.键盘驱动程序不能体现多线程系统的特点，因为计算机一般只有一个键盘                                                                            |
## 进程与线程的区别
|            |                                                           |                                                                              |
| ---------- | --------------------------------------------------------- | ---------------------------------------------------------------------------- |
|            | 进程                                                        | 线程                                                                           |
| 是什么的单位?    | 是资源分配的基本单位                                                | 是调度的基本单位                                                                     |
| 不能共享什么?    | 不能共享虚拟地址空间                                                | 不能共享栈指针                                                                      |
| 可以共享什么?    | 拥有一个完整的资源平台  <br>每个进程都有独立的地址空间和资源  <br>除了共享全局变量，不允许其他进程访问 | 某进程中的线程对其他进程不可见<br><br>线程共享进程的地址空间和资源，线程自己没有独立的地址空间<br><br>只独享必不可少的资源，如寄存器和栈 |
| 进程切换会引起什么? | 不同进程的线程的切换会引起进程切换                                         | 同一进程的线程的切换不会引起进程切换                                                           |
| 创建,终止,切换时间 | 慢                                                         | 快                                                                            |
| 数据交换效率     | 低                                                         | 各线程间共享内存和文件资源，数据交换效率高                                                        |
## 线程的概念和特征
|                  |                                                                                                                  |
| ---------------- | ---------------------------------------------------------------------------------------------------------------- |
| 定义               | - 线程是进程当中的一条执行流程<br>- 线程之间可以并发运行且共享相同的地址空间<br>- 线程自己不拥有系统资源，但可与同属一个进程的程序共享进程所有的资源<br>- 线程同样具有三种基本状态 ：运行态+阻塞态+就绪态 |
| 为什么要引入线程?        | 为了减少程序在并发执行过程中所付出的时空开销，提高操作系统的并发能力                                                                               |
| 为什么线程有利于提高系统并发性? | 线程可以导致平均每次切换所需开销变少，使得更多线程参与并发                                                                                    |
|                  |                                                                                                                  |
## 线程的组成和控制
### 组成
• 与进程类似，每个线程配置一个线程控制块TCP
• TCP的功能：记录控制和管理线程的信息
• TCP的组成：线程标识符+一组寄存器+线程运行状态+优先级+线程专有存储区+堆栈指针++现场（通用寄存器，PC以及用户栈指针对于OS支持的线程）+调度参数
## 控制
创建和终止线程
## 线程的分类
程的实现分为两类 = 用户级线程(User-Level Thread, ULT) + 内核级线程(Kernel-Level Thread, KLT)

|     |                                                                                                     |                                                             |
| --- | --------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- |
|     | ULT                                                                                                 | KLT                                                         |
| 定义  | 由用户级线程库函数来完成整个线程的管理和调度【库函数负责】                                                                       | 线程对应的TCB放在OS里，线程的管理和调度由OS负责【OS负责】                           |
| 模型  | 多对一模型（多个用户对应一个线程）                                                                                   | 一对一模型（一个用户对应一个线程）                                           |
| 优点  | - TCB由用户级线程库函数维护，可用于不支持线程技术的OS<br><br>- 无需用户态和内核态的切换，速度比KLT快                                        | - 某个内核线程发起系统调用被阻塞，不会影响到其他内核线程的运行<br>- 内核能同时调度同一进程中的多个线程并行执行 |
| 缺点  | - 一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了<br>- 在多线程执行时，每个线程得到的时间片少，执行慢<br>- 📢线程与线程之间不用内核切换，但是跨进程的话就需要内核参与 | - 同一进程的线程切换，需要从用户态转到核心态，系统开销大                               |
## 多线程模式
式
|     |                                                                   |                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| --- | ----------------------------------------------------------------- | ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|     | 多对一模型                                                             | 一对一模型                         | 多对多模型                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| 定义  | 多个ULT映射到一个KLT                                                     | 每个ULT映射到一个KLT                 | n个ULT映射到m个KLT，![](data:image/png;base64,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) |
| 优点  | - 线程管理在用户空间进行，效率高                                                 | - 一个线程被阻塞，运行调度另一个线程运行，并发能力强   | - 克服了多对一模型的并发度不高的缺点<br>- 克服了一对一模型的一个用户进程占用太多内核线程而开销大的缺点                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| 缺点  | - 如果一个线程阻塞，其他进程都会被阻塞<br>- 任何时刻，只有一个线程能访问内核<br>- 多个线程不能同时在多个处理机上运行 | - 每创建一个用户线程，就要创建一个对应的内核线程，开销大 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
# 处理机调度

|                                                                                                                            |
| -------------------------------------------------------------------------------------------------------------------------- |
| 1.作业是用户提交的，以用户任务为单位                                                                                       |
| 2.进程是系统自动生成的，以操作系统控制为单位                                                                               |
| 3.进程的调度就是把一个进程从就绪态转换为了运行态，有很多事件会导致进程的调度。                                             |
|                                                                                                                            |
| 1.调度是处理机进行分配，即从就绪队列中按一定算法(公平，高效的原则)选择一个进程并将处理机分配给他运行，以实现进程并发地执行 |
| 2.调度是多道程序OS的基础；调度是OS设计的核心问题                                                                           |
|                                                                                                                            |
## 调度的层次分类
![Pasted image 20240710191840](https://github.com/user-attachments/assets/5081185b-2038-4a20-8f72-bc7b733f766c)

|             |                                                                                                                    |
| ----------- | ------------------------------------------------------------------------------------------------------------------ |
| 1.高级调度/作业调度 | - 是内存与辅存的调度，从后备队列中调度作业<br>- 每个作业只调入调出一次<br>- 通常存在于多道批处理系统中<br>- 内存与磁盘之间交换数据的状态转换：就绪态到挂起态（408不考挂起）                  |
| 2.中级调度/内存调度 | - 目的是提高内存利用率和系统吞吐量<br><br>- 将暂时不能运行的进程调到外存等待，设为挂起态，最后修改状态为就绪态，挂在就绪队列上<br>- 是存储器管理中的对换功能                            |
| 3.低级调度/进程调度 | - 从就绪队列中选取一个进程，调用频率很高<br>- 各种OS都必须配置这种调度                                                                           |
| 三种调度的联系     | 1.作业调度为进程活动做准备，进程调度使进程正常活动  <br>2.中级调度将暂时不能运行的进程挂起，中级调度处于另外两个调度之间  <br>3.调用频率：作业调度<内存调度<进程调度  <br>4.进程调度是最基本的，不可或缺 |
## 调度的实现
![Pasted image 20240710192059](https://github.com/user-attachments/assets/e8af0fd5-9771-42e9-b806-4f40d777ad24)
### 调度器的组成
| 调度器是什么？  | 用于调度和分派CPU的组件            |
|----------|--------------------------|
| 1.排队器    | 按策略给就绪进程排出一个或多个队列        |
| 2.分派器    | 从就绪队列中取出进程，并分配CPU        |
| 3.上下文切换器 | 在对处理机进行切换时，会发生两对上下文的切换操作 |
## 调度的时机
- 先调度再切换
- 如果就绪队列中还有其他队列，则一个进程从阻塞态到就绪态时不一定会发生调度
- 调度时机举例
	- 运行的进程运行完毕
	- 运行的进程时间片用完
	- 运行的进程所需资源未准备好
	- 运行的进程自我阻塞
	- 运行的进程出现错误
## 进程的切换
| 不能进行调度与切换的情况 | • 在处理中断的过程中                          |
|--------------|--------------------------------------|
|              | • 进程在OS内核临界区中                        |
|              | • 其他需要完全屏蔽中断的原子操作过程中                 |
| 可以进行调度与切换的情况 | • 发生引起调度条件且当前进程无法继续进行下去时（非剥夺调度）      |
|              | • 中断处理结束或自陷处理结束后，被置上请求调度标志（剥夺方式的调度）  |
|              | • 在进程结束时能进行处理机调度                     |
|              | • 创建新进程后能进行处理机调度                     |
|              | • 在系统调用完成并返回用户态时能进行处理机调度             |
|              | • 进程处于临界区时，只要不破坏临界资源的使用规则，就不影响处理机的调度 |
## 切换的过程
1. 将原进程的信息推入到当前进程的内核堆栈中，并更新堆栈指针
2. 内核从新进程的内核栈中装入新进程的信息
3. 内核更新当前运行的进程空间指针，重设PC寄存器后开始运行新的进程
## 调度方式
|     |                    |                             |
| --- | ------------------ | --------------------------- |
|     | 非抢占调度方式            | 抢占调度方式                      |
| 优点  | 实现简单，系统开销小，适合批处理系统 | 有利于提高系统吞吐率和响应效率             |
| 缺点  | 不适合分时和大多数的实时系统     | 必须遵循一定的准则(如优先级，短进程优先，时间片原则) |
## 与调度相关的指标
- $CPU利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲时间}$
- $周转时间=作业完成时间-作业提交时间$
- $带权周转时间=\frac{周转时间}{作业实际运行时间}$
- $平均周转时间=\frac{\sum{t_i}}{i}$
- $平均带权时间=\frac{\sum{W_i}}{i}$
# 调度算法
- 调度算法
		- 作业调度：
			- FCFS（先来先服务，First come first servered）
				- 算法内容：调度作业、就绪队列中最先入队者，等待操作完成或阻塞
				- 算法原则：按作业/进程到达顺序执行
				- 调度方式：非抢占式
				- 适用场景：作业/进程调度
				- 优缺点
					- 有利于CPU繁忙的作业，充分利用
					- 不利于I/O繁忙的，操作耗时，其他饥饿
			- SJF(短作业优先，Shorest Job first)
				- 算法内容：所需服务时间最短的作业/进程优先服务
				- 算法原则：追去最少的平均(带权)周转时间
				- 调度方式SJF/SPF非抢占式
				- 优缺点
					- 平均等待/周转时间最少
					- 长作业周转时期会增加或饥饿
					- 估计时间不准确，不能保证紧迫任务及时处理
			- HRRN(高相应比优先调度，Highest Response Ratui Next)
				- 算法内容：结合FCFS，SJF综合考虑等待时间和服务时间计算响应比，高的优先调度
				- 算法原则：综合考虑作业/进程的等待时间和服务时间
				- 调度方式：非抢占式
				- 适用场景：作业/抢占调度
				- 响应比计算：
					- 响应比=（等待时间+服务时间）/服务时间>=1
					- 只有当前进程放弃执行权时，重新计算响应比
					- 长作业等待越久，响应比越高
			- PSA(优先级调度，Priority-Scheduling Algorithm)
				- 算法内容:又叫优先权调度，按作业/进程的优先级调度
				- 算法原则：优先级最高的作业.进程现调度
				- 调度方式:抢占/非抢占式
				- 优先级设置原则：
					- 静态/动态优先级
					- 系统>用户，交互性>非交互性，I/O>计算型
					- 低优先级可能会饥饿
		- 进程调度
			- RR(时间片轮转调度，Round-Robin)
				- 算法内容：按进程到达就绪顺序，轮流分配一个时间片，时间用完就剥夺
				- 算法原则：公平，轮流为每个进程服务，进程在一定时间内都能得到响应
				- 调度方式：抢占式、由时钟中断确定时间到
				- 使用场景：进程调度
				- 优缺点：
					- 公平，响应快，适用于分时系统
					- 时间片决定因素：系统响应时间，就绪队列进程数量，系统处理能力
					- 时间片太多相当于FCFS，太小，处理及频繁切换。开销增大
			- **MFQ(多级反馈队列调度，Multileveled Feedback Queue)**
				- 算法内容:设置多个按优先级排序的就绪队列。优先级从高到低，时间片，从小到大，新进程次啊用队列降级法：进入第一季队列，按FCFS分时间片，没有执行完，移到第二级，第三级。。前面队列不为空，不执行后续队列进程
				- 算法原则：集前几种算法优点，相当于PSA+RR
				- 调度方式：抢占式
				- 适用场景：进程调度
				- 优缺点：
					- 对各类型相对公平，快速响应
					- 终端型作业用户：短作业优先
					- 批处理用户：周转时期短
					- 长批处理用户：在前几个队列部分执行
## 调度算法对比
|        |                                                                       |                          |                                    |                                             |                                  |
| ------ | --------------------------------------------------------------------- | ------------------------ | ---------------------------------- | ------------------------------------------- | -------------------------------- |
|        | FCFS                                                                  | SJF                      | 高响应比                               | 时间片轮转                                       | 多级反馈队列                           |
| 可抢占？   | ×                                                                     | √                        | √                                  | √                                           | 队列内算法不一定                         |
| 不可抢占？  | √                                                                     | √                        | √                                  | ×                                           | 队列内算法一不一定                        |
| 特点&优点  | - 公平<br>- 实现简单<br>- 有利于长作业<br>- 不利于短作业<br>- 有利于CPU繁忙作业<br>- 不利于IO繁忙作业 | - 平均等待时间最少<br><br>- 效率最高 | - 兼顾长短作业<br><br>- 满足短作业优先且不会发生饥饿现象 | - 兼顾长短作业<br>- 为了多个用户能及时干预系统<br><br>- 绝对可抢占的 | - 兼顾长短作业<br>- 有较好的响应时间<br>- 可行性强 |
| 缺点     | - 不利于短作业                                                              | - 长作业会饥饿<br>- 估计时间不易确定   | - 计算响应比的开销大                        | - 平均等待时间最长<br><br>- 上下文切换浪费时间               | 无                                |
| 适用于    | 无                                                                     | - 作业调度<br><br>- 批处理系统    | 无                                  | - 分时系统<br><br>- 适用于人机交互系统                   | - 相当通用<br>- 大家都满意的算法             |
| 默认决策模式 | 非抢占                                                                   | 非抢占                      | 非抢占                                | 抢占                                          | 抢占                               |
# 同步与互斥
|                                                                                                                                                        |                                                                     |
| ------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------- |
| 1、可重入代码/纯代码：一种允许多个进程同时访问的代码；如进程映像中的共享程序段                                                                                                               |                                                                     |
| 2、PV操作实现的同步的S的初值由用户确定；如果期望的信息还没发送，则对应的初值为0，若信息已存在，则初值为非0的正数<br><br>     PV操作实现的互斥的S的初值=1                                                               |                                                                     |
| 3、执行P操作的进程处于运行态；若P操作之后，S<0，则表示没有可用资源，该进程进入阻塞状态                                                                                                         |                                                                     |
| 4、判断代码中的语句是否要互斥执行，可以从以下几个方面考虑<br><br>- 不同范围的变量不需要互斥（如进程A和进程B都有变量x，这是两个不同范围的变量，不用互斥）<br>- 对变量赋值前，都有声明语句的话，不需要互斥（如「int a; a=1; int a; a=2」,a=1和a=2不需要互斥） |                                                                     |
| 5、信箱通信是一种间接通信                                                                                                                                          |                                                                     |
|                                                                                                                                                        |                                                                     |
| 为什么要引入同步互斥？                                                                                                                                            | 因为并发进程是异步的，为了协调进程之间的相互制约关系，所以引入同步互斥                                 |
| 进程的异步性是什么？                                                                                                                                             | 由于系统的资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进                         |
| 并发过程执行产生的两种相互制约关系                                                                                                                                      | <br>\|同步\|- 进程 A 应在进程 B 之前执行\|<br>\|互斥\|- 进程 A 和进程 B 不能在同一时刻执行\|    |
| 临界资源                                                                                                                                                   | 一次仅允许一个进程使用的资源；如物理设备(打印机)，共享变量，共享数据，共享缓冲区，公用队列                      |
| 共享资源                                                                                                                                                   | 可用被多个进程同时使用的资源；如可重入代码/纯代码，共享程序段，磁盘，非共享数据                            |
| 临界区                                                                                                                                                    | - 访问临界资源的那段代码<br>- 如果n个进程涉及到了同一个变量A，则A的相关临界区 = 访问临界资源A的那段代码 = n个代码段 |
## 同步机制进行的原则
| 空闲让进 | • 临界区空闲，允许一个进程进入【运行进程访问空闲的临界资源】                      |
|------|------------------------------------------------------|
| 忙则等待 | • 有进程进入临界区时，其他进程需等待【两个进程不能同时进入临界资源】                  |
| 有限等待 | • 请求访问的进程应保证在有限时间内进入临界区【进程等待进入临界区的时间是有限的】            |
| 让权等待 | • 进程不能进入临界区时，应该立即释放处理器，防止进程忙等待【不能进入临界区的执行态进程立即放弃CPU】 |
## 进程同步与互斥机制1：硬件和软件方法（感觉这里考的不多，主要还是考PV操作）
|      |                                                                                |
| ---- | ------------------------------------------------------------------------------ |
| 硬件方法 | 中断屏蔽方法；硬件指令方法；swap指令；TestAndSet指令（详见书P90）                                      |
| 软件方法 | 单标志法；双标志法先检查，双标志法后检查；Peterson's Algorithm（详见书P90）                              |
| 注意点  | 【硬件方法实现同步时不能实现让权等待】  <br>【Peterson算法满足有限等待但不满足让权等待】  <br>【记录型信号量引入阻塞机制，可以让权等待】 |
## 进程同步与互斥机制2：管程
|     |                                                                                                                                                                                                          |
| --- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 定义  | - 管程定义了共享数据结构和各种进程在该数据结构上的全部操作<br>- 结构类似于Class，把对共享资源的操作封装起来<br>- 管程支持进程互斥；任何时候只有一个进程在管程中执行<br>- 管程不仅能实现进程间的互斥，还能实现进程间的同步<br>- Java 采用管程机制<br>- Java中管程常见的代码：synchronized关键字，wait()、notify()、notifyAll() |
| 组成  | 1. 管程的名字<br>2. 局部于管程内部的共享数据结构或者共享变量说明<br>3. 对管程内的数据结构进行操作的一组过程<br>4. 对局部于管程内部的共享数据设置初始值的语句<br><br>📢这类题目如果看到是管程外这个字眼，那就是错误的，管程的组成都是基于管程内部的                                                               |
### 管程中设置的条件变量
| 定义       | • 阻塞原因定义为条件变量condition                           |
|----------|--------------------------------------------------|
| 有两种操作    | • x.wait：阻塞进程，将其插入到阻塞队列中                         |
|          | • x.signal：唤醒进程，将其插入到就绪队列中                       |
| 与信号量的相似点 | • wait/signal类似于信号量的P/V操作，实现进程的阻塞/唤醒，但不能说和PV操作相同 |
| 与信号量的不同点 | • 条件变量没有值，仅实现“排队等待”功能                            |
|          | • 信号量有值，这个值反映了剩余资源数                              |
## 进程同步与互斥机制3：互斥锁
|     |                                    |
| --- | ---------------------------------- |
| 定义  | - 解决临界区最简单的工具                      |
| 特点  | - 通常采用硬件机制实现<br>- 常用于多处理器系统        |
| 缺点  | - 缺点：忙等待                           |
| 代码  | - acquire()获取🔐<br>- release()释放🔐 |
# 进程同步与互斥机制4：信号量和PC操作
## PV操作定义
| P操作 | • 将信号量值S减 1，表示「申请占用一个资源」                                    |
| --- | ----------------------------------------------------------- |
|     | • 如果 s<0，表示已经没有可用资源，则执行 P 操作的进程被阻塞                          |
|     | • 如果 s≥0，表示现有的资源足够你使用，则执行 P 操作的进程继续执行                       |
|     | • 举例：当信号量的值为2时，表示有 2 个资源可以使用；当信号量的值为-2的时候，表示有两个进程正在等待使用这个资源 |
| V操作 | • 将信号量值S加 1，表示「释放一个资源」，即使用完资源后归还资源                          |
|     | • 如果s≤0，表示有某些进程正在等待该资源                                      |
|     | • 由于我们已经释放出一个资源了，因此需要唤醒阻塞进程                                 |
|     |                                                             |
### S>0表示有临界资源可供使用，这个时候为什么不需要唤醒进程？
- 所谓唤醒进程是从就绪队列（阻塞队列）中唤醒进程，而信号量的值大于 0 表示有临界资源可供使用
- 也就是说这个时候没有进程被阻塞在这个资源上，所以不需要唤醒，正常运行即可
### S=0表示没有临界资源可供使用，为什么还要唤醒进程？
- V 操作是先执行S+1，也就是说，把信号量的值加1后才变成了0
- 在此之前，信号量的值是-1，即有一个进程正在等待这个临界资源，我们需要唤醒它
```C
typedef struct semaphore{
		int value;
		struct pcb * list;
}
void p(semaphore s){
	s.value--;
	if(s.value<0){
		asleep(s.list);
	}
}
void v(semaphore s){
	s.value++;
	if(s<=0){
	wakeup(s.list);
	}
}
```
- 原子操作就是要么全部执行，要么都不执行，不能出现执行到一半的中间状态的操作
- PV操作是低级进程通信语言
## 信号量分类
| 整型信号量  | • 该信号量被定义为一个用于表示资源数目的整型量S  |
|--------|----------------------------|
|        | • 该机制不遵循“让权等待”的准则          |
| 记录型信号量 | • 是一种不存在“忙等”现象的进程同步机制      |
|        | • 需要一个用于代表资源数目的变量Value     |
|        | • 需要一个进程链表L，用于链接所有等待该资源的进程 |
|        | • wait操作 = P操作 = 请求一个资源    |
|        | • signal操作 = V操作 = 释放一个资源  |
|        | • 该机制遵循“让权等待”的准则           |
## 信号量应用
### 利用信号量实现同步
- 用资源P操作；释放资源V操作；此时信号量表示资源量

|                          |
| ------------------------ |
| 同步信号量初始值不确定，可以设置         |
| 信号量最大值 = 最多可以请求的资源数      |
| 信号量最小值 = 最大值/初始值 - 最大请求值 |
### 利用信号量实现互斥
- PV操作夹着互斥资源；此时信号量表示互斥量

|                                    |
| ---------------------------------- |
| 互斥信号量初始值=1，表示临界区只运行一个进程进入，从而实现互斥   |
| 互斥信号量=0，表示临界区已经有一个进程进入，临界区外还没有进程等待 |
| 互斥信号量<0，表示临界区中有一个进程                |
| \|互斥信号量\| 表示在临界区外等待进入的进程数          |
## 实现进程同步
step1：定义一个同步信号量，并初始化为当前可用资源的数量
step2：在优先级较「高」的操作的「后」面执行 V 操作,释放资源
step3：在优先级较「低」的操作的「前」面执行 P 操作,申请占用资源
```C
semaphore s=0;
p1(){
	1;
	2;
	V(s);
	3;
}
p2(){
	P(s);
	4;
	5;
	6;
}
```
![Pasted image 20240710200926](https://github.com/user-attachments/assets/d88fdad3-bbad-4c39-88f7-b86d2f1bf3f5)
## 实现进程互斥
step1：定义⼀个互斥信号量，并初始化为 1
step2：把对于临界资源的访问置于 P 操作和 V 操作之间 
- 「P 操作和 V 操作必须成对出现」 
- 缺少 P 操作就不能保证对临界资源的互斥访问  
- 缺少 V 操作就会导致临界资源永远得不到释放、处于等待态的进程永远得不到唤醒
```C
semaphore mutex =1;
p1(){
	P(mutex);
	临界区；
	V(mutex);
}
P2(){
	P(mutex);
	临界区；
	V(mutex);
}
```
# 经典同步问题
