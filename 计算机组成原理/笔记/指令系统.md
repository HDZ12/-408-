# 什么是指令
- 指令【又称机器指令】 是指示计算机执行某种操作的命令，是计算机运行的最小功能单位
- 一条指令就是机器语言的一个语句，它是一组有意义的二进制代码
- 一台计算机的所有指令的集合构成该机的指令系统，也称为指令集
- 指令系统是计算机的主要属性，位于硬件和软件的交界面上
# 指令格式
## 基本指令结构
- 一条指令通常要包括操作码字段和地址码字段
- 【操作码字段】告诉用户做什么操作
- 【地址码】告诉用户对谁操作？
- 指令的地址由程序计数器给出

![Pasted image 20240620171042](https://github.com/user-attachments/assets/ca74ca69-9401-41de-b75f-9fda75870076)
# 指令的分类
![按指令长度分类](https://github.com/user-attachments/assets/a2323708-606f-4d9b-8c78-abce2438fb9d)

![按是否定长分类](https://github.com/user-attachments/assets/41275b37-e1ed-40ab-b029-c581b0751cf8)

主存一般按字节编制，所有指令字长多为字节的整数倍
# 具体指令结构
## 指令字长32位
【操作码(OP)8位】+【地址码(A)共4个，每个6位】
## 指令访存的过程
- 首先000000这个位置上存放着操作指令
- A1，A2上存着两串数
- 他们在000000指令的执行下，要进行加法操作，将结果填入到A3中
- A3中的数据就是A1+A2的和
- 最后再去A4读取出指令，开始下一轮工作


![Pasted image 20240620185216](https://github.com/user-attachments/assets/064e02f1-d30c-41f6-b91c-51090bf71612)
> 内存中既有操作码，又有地址码,这样把他们放在一起并不好可以优化他们
> - 把操作码放一起，地址码放一块
> - 通过程序计数器使操作码+1顺序执行
### 优化后的好处
- 将操作码放一块，我们可以让程序执行完一步就自动执行下一句指令
- 这样我们的指令就不用存放下一条指令的位置了
- 这样访存的次数少了一次，速度也会快点
- 如无例外（特例指的是跳转指令），执行完就直接下一条继续，也就是顺序执行


![Pasted image 20240620185409](https://github.com/user-attachments/assets/989cd24f-e511-4b0f-870d-ddbf1af92459)

操作码和地址码放一起


![Pasted image 20240620185440](https://github.com/user-attachments/assets/cead0c85-faa6-42ce-8eb9-cafd83002469)

操作码和地址码分组存放
# 地址码
【三，四地址指令】
- 原先每一条地址码最多只能寻址到2的6次方也就是64个地址
- 而现在地址搜寻的范围变成了2的8次方也就是256个地址
- 寻址的范围大大增加了
- (A1)OP(A2)---->A3
- A4 = 下一条将要执行指令的地址
【二地址指令】
- 对两个数进行操作完后结果覆盖到原来的地址上的数
- 如将A1和A2相加，结果返回到A1
- (A1)OP(A2)--->A1


![Pasted image 20240620185733](https://github.com/user-attachments/assets/efe6d33c-caf0-444c-be38-fea81d413530)

【一/单地址指令】

第一种

- 只有目的操作数的单操作数指令
- 进行自身操作的数(比如自增、自减、取反，求补)
- OP(A1)---->A1

第二种

- 蕴含约定目的地址的双操作数指令
- 地址码A1指明一个操作数
- 另一个操作数来自隐含寻址，由ACC提供
- (ACC)OP(A1)---->ACC


![Pasted image 20240620185819](https://github.com/user-attachments/assets/c1236a13-0282-464a-9a56-516162c978f8)

【零地址指令】
- 只给出操作码OP，没有显示地址

第一种

- 不需要操作数的指令：空操作指令，停机指令，关中断指令

第二种

- 堆栈计算机中，两个操作数来自堆栈的栈顶和次栈顶单元


![Pasted image 20240620185908](https://github.com/user-attachments/assets/ca94d2fc-1a89-4a75-9fcd-772dbe2256f1)
# 操作码
# 扩展操作码==（考计算）==
- 保持指令字长度不变而增加寻址空间
- 如果我们将前面的4位全部用作操作码，则一共能发出0000~1111【16种操作】
- 现在舍弃一条操作（1111），只发出0000~1110 【15种操作】
- 将1111留着作为标记，如果是1111开头的，则代表A1也作操作码(下图标记有问题)
- 将11111111留着作为标记，如果是1111 1111开头的，则代表A2也作操作码(下图标记有问题)
- 全为操作码，没有地址码--->零地址指令


![Pasted image 20240620191012](https://github.com/user-attachments/assets/47e13ad2-7a44-42a7-b489-d72b21ebc3e5)


![Pasted image 20240620191049](https://github.com/user-attachments/assets/da0199fb-cc3b-496f-8352-d1d483e625e8)

![Pasted image 20240620191049](https://github.com/user-attachments/assets/4d5d9e77-b6ad-4561-8d21-7f788c0e5449)


![Pasted image 20240620191152](https://github.com/user-attachments/assets/89e9111b-a011-42e8-95f3-d27c8555a1cc)
## 定长操作码
一般用在指令长度比较长的机器上，就不用那么拘束调来调去
- 对使用频率较高的指令，分配较短的操作码
- 对使用频率较低的指令，分配较长的操作码
- 从而尽可能减少指令译码和分析的时间
- 各指令的操作码一定不能重复
- 拓展操作码不一定只能有一条，也就是说不一定只有1111作拓展操作码，对应15条地址，也可以1110、1111都做拓展码，留14条地址指令也行，甚至不要14条地址指令，只要13条、12条也可以，所有操作码的设计都符合下面的规则
- 设地址长度位n，上一层流出m条指令，下一层可以扩展出 $m*2^n$ 条指令


![Pasted image 20240620192543](https://github.com/user-attachments/assets/c3e00e59-69f6-47bf-a00d-b71d822499d3)
## 操作类型
### 数据传送类
- 进行CPU和主存之间的数据传送
- LOAD作用:把存储器中的数据放到寄存器中
- STORE作用:把寄存器中的数据放到存储器中
### 运算类
- 算术-----加、减、乘、除、增1、减1、求补、浮点运算、十进制运算
- 逻辑-----与、或、非、异或、位操作、位测试、位清除、位求反
- 移位操作---算术移位、逻辑移位、循环移位(带进位和不带进位)
### 程序控制类
- 改变程序执行的顺序
- 「无条件转移JMP」「 条件转移BRANCH」
- 「调用CALL」「返回RETURN」「陷阱Trap」
- 📢调用指令和转移指令的区别：前者必须保存下一条指令的地址，当子程序执行结束时，根据返回地址返回到主程序继续执行，后者不需要返回
- 转移指令，子程序调用与返回指令用于解决变动程序中指令执行次序的需求，而不是数据调用次序的需求
### 输入输出类
- 进行CPU和I/0设备之间的数据传送
- 传送控制命令和状态信息
