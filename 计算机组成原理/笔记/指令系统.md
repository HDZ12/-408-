# 什么是指令
- 指令【又称机器指令】 是指示计算机执行某种操作的命令，是计算机运行的最小功能单位
- 一条指令就是机器语言的一个语句，它是一组有意义的二进制代码
- 一台计算机的所有指令的集合构成该机的指令系统，也称为指令集
- 指令系统是计算机的主要属性，位于硬件和软件的交界面上
# 指令格式
## 基本指令结构
- 一条指令通常要包括操作码字段和地址码字段
- 【操作码字段】告诉用户做什么操作
- 【地址码】告诉用户对谁操作？
- 指令的地址由程序计数器给出

![Pasted image 20240620171042](https://github.com/user-attachments/assets/ca74ca69-9401-41de-b75f-9fda75870076)
# 指令的分类
![按指令长度分类](https://github.com/user-attachments/assets/a2323708-606f-4d9b-8c78-abce2438fb9d)

![按是否定长分类](https://github.com/user-attachments/assets/41275b37-e1ed-40ab-b029-c581b0751cf8)

主存一般按字节编制，所有指令字长多为字节的整数倍
# 具体指令结构
## 指令字长32位
【操作码(OP)8位】+【地址码(A)共4个，每个6位】
## 指令访存的过程
- 首先000000这个位置上存放着操作指令
- A1，A2上存着两串数
- 他们在000000指令的执行下，要进行加法操作，将结果填入到A3中
- A3中的数据就是A1+A2的和
- 最后再去A4读取出指令，开始下一轮工作


![Pasted image 20240620185216](https://github.com/user-attachments/assets/064e02f1-d30c-41f6-b91c-51090bf71612)
> 内存中既有操作码，又有地址码,这样把他们放在一起并不好可以优化他们
> - 把操作码放一起，地址码放一块
> - 通过程序计数器使操作码+1顺序执行
### 优化后的好处
- 将操作码放一块，我们可以让程序执行完一步就自动执行下一句指令
- 这样我们的指令就不用存放下一条指令的位置了
- 这样访存的次数少了一次，速度也会快点
- 如无例外（特例指的是跳转指令），执行完就直接下一条继续，也就是顺序执行


![Pasted image 20240620185409](https://github.com/user-attachments/assets/989cd24f-e511-4b0f-870d-ddbf1af92459)

操作码和地址码放一起


![Pasted image 20240620185440](https://github.com/user-attachments/assets/cead0c85-faa6-42ce-8eb9-cafd83002469)

操作码和地址码分组存放
# 地址码
【三，四地址指令】
- 原先每一条地址码最多只能寻址到2的6次方也就是64个地址
- 而现在地址搜寻的范围变成了2的8次方也就是256个地址
- 寻址的范围大大增加了
- (A1)OP(A2)---->A3
- A4 = 下一条将要执行指令的地址
【二地址指令】
- 对两个数进行操作完后结果覆盖到原来的地址上的数
- 如将A1和A2相加，结果返回到A1
- (A1)OP(A2)--->A1


![Pasted image 20240620185733](https://github.com/user-attachments/assets/efe6d33c-caf0-444c-be38-fea81d413530)

【一/单地址指令】

第一种

- 只有目的操作数的单操作数指令
- 进行自身操作的数(比如自增、自减、取反，求补)
- OP(A1)---->A1

第二种

- 蕴含约定目的地址的双操作数指令
- 地址码A1指明一个操作数
- 另一个操作数来自隐含寻址，由ACC提供
- (ACC)OP(A1)---->ACC


![Pasted image 20240620185819](https://github.com/user-attachments/assets/c1236a13-0282-464a-9a56-516162c978f8)

【零地址指令】
- 只给出操作码OP，没有显示地址

第一种

- 不需要操作数的指令：空操作指令，停机指令，关中断指令

第二种

- 堆栈计算机中，两个操作数来自堆栈的栈顶和次栈顶单元


![Pasted image 20240620185908](https://github.com/user-attachments/assets/ca94d2fc-1a89-4a75-9fcd-772dbe2256f1)
# 操作码
# 扩展操作码
- 保持指令字长度不变而增加寻址空间
- 如果我们将前面的4位全部用作操作码，则一共能发出0000~1111【16种操作】
- 现在舍弃一条操作（1111），只发出0000~1110 【15种操作】
- 将1111留着作为标记，如果是1111开头的，则代表A1也作操作码(下图标记有问题)
- 将11111111留着作为标记，如果是1111 1111开头的，则代表A2也作操作码(下图标记有问题)
- 全为操作码，没有地址码--->零地址指令


![Pasted image 20240620191012](https://github.com/user-attachments/assets/47e13ad2-7a44-42a7-b489-d72b21ebc3e5)


![Pasted image 20240620191049](https://github.com/user-attachments/assets/da0199fb-cc3b-496f-8352-d1d483e625e8)

![Pasted image 20240620191049](https://github.com/user-attachments/assets/4d5d9e77-b6ad-4561-8d21-7f788c0e5449)


![Pasted image 20240620191152](https://github.com/user-attachments/assets/89e9111b-a011-42e8-95f3-d27c8555a1cc)
## 定长操作码
一般用在指令长度比较长的机器上，就不用那么拘束调来调去
- 对使用频率较高的指令，分配较短的操作码
- 对使用频率较低的指令，分配较长的操作码
- 从而尽可能减少指令译码和分析的时间
- 各指令的操作码一定不能重复
- 拓展操作码不一定只能有一条，也就是说不一定只有1111作拓展操作码，对应15条地址，也可以1110、1111都做拓展码，留14条地址指令也行，甚至不要14条地址指令，只要13条、12条也可以，所有操作码的设计都符合下面的规则
- 设地址长度位n，上一层流出m条指令，下一层可以扩展出 $m*2^n$ 条指令


![Pasted image 20240620192543](https://github.com/user-attachments/assets/c3e00e59-69f6-47bf-a00d-b71d822499d3)
## 操作类型
### 数据传送类
- 进行CPU和主存之间的数据传送
- LOAD作用:把存储器中的数据放到寄存器中
- STORE作用:把寄存器中的数据放到存储器中
### 运算类
- 算术-----加、减、乘、除、增1、减1、求补、浮点运算、十进制运算
- 逻辑-----与、或、非、异或、位操作、位测试、位清除、位求反
- 移位操作---算术移位、逻辑移位、循环移位(带进位和不带进位)
### 程序控制类
- 改变程序执行的顺序
- 「无条件转移JMP」「 条件转移BRANCH」
- 「调用CALL」「返回RETURN」「陷阱Trap」
- 📢调用指令和转移指令的区别：前者必须保存下一条指令的地址，当子程序执行结束时，根据返回地址返回到主程序继续执行，后者不需要返回
- 转移指令，子程序调用与返回指令用于解决变动程序中指令执行次序的需求，而不是数据调用次序的需求
### 输入输出类
- 进行CPU和I/0设备之间的数据传送
- 传送控制命令和状态信息
# 寻址方式
- 指令系统采用不同寻址方式的目的：缩短指令字长，扩大寻址空间，提高编程的灵活性
## 什么是指令寻址
- 指令寻址就是寻找下一条将要执行的指令地址
## 程序计数器
- 程序计数器pc是指让程序执行完一步就自动执行下一句指令的物理硬件
- 机器按字寻址，PC给出下一条指令字的访存地址(指令在内存中的地址)，因此PC的位数取决于存储器的字数
- 机器按字寻址，指令寄存器IR用于接收取得的指令，因此IR的位数取决于指令字长
## 指令寻址的分类
### 顺序寻址
通过程序计数器加1(1是指指令字长)，自动形成下一条指令的地址
### 跳跃寻址
- 通过转移类指令（如相对寻址）实现，可用来实现程序的条件或无条件转移
- 跳跃：指下条指令的地址不由PC自动给出，而由本条指令给出下条指令地址的计算方式
- 跳跃的地址分为绝对地址【由标记符直接得到】和相对地址【相对于当前指令地址的偏移量】
- 跳跃的结果是当前指令修改PC值，所以下一条指令仍然通过PC给出


![Pasted image 20240620194956](https://github.com/user-attachments/assets/46558105-960b-4be2-a101-6651f3610581)
## 数据寻址
- 数据寻址就是确认本条指令的操作数【是操作数不是操作码】地址
## 地址码的组成
• 地址码 = 寻址特征+形式地址 

	○ 寻址特征 = 存的就是每个寻址方式上的蓝色小标，表示一种方式 
 
	○ 形式地址A = 就是不是直接对应到存储器中的地址，是需要根据寻址特征的要求转换为对应存储器的地址 
 
	○ 有效地址EA = 通过寻址特征和形式地址求出来的真正对应到存储器的地址 

 ![Pasted image 20240620195145](https://github.com/user-attachments/assets/a066e5b5-ebe8-4083-aac1-dffe6851c945) \
A表示A这个地址，(A)表示地址为A里面的内容 

EA=A表示形式地址A就是真实地址EA

EA=(A)表示形式地址A的内容是真实地址EA
# 常见的寻址方式
## 访问主存空间的
### 隐含寻址
#### 有效地址
程序指定
#### 知识点
【定义】
- 不直接给出操作数的地址，而是在指令中就隐含操作数的地址
【寻址过程】
- 形式地址A取出对应的一个操作数
- 而另一个操作数则是通过隐含寻址方式的指令设置，隐含在了ACC中
【特点】
- 隐地址不给出明显的操作数地址，而在指令中隐含操作数的地址
- 可以简化地址结构，如零地址指令


![Pasted image 20240620195602](https://github.com/user-attachments/assets/48c6b9a0-b119-4d6c-9872-10c097169e3c)
### 立即寻址
#### 有效地址
A就是操作数
#### 知识点
【定义】

- 把我们实际要操作的数，直接存放在形式地址中

【寻址过程】

- 寻址特征为#，代表立即寻址的意思
- 形式地址写的是操作数3的补码（011）

【特点】

- 立即寻址主要执行取指令访存1次，不需要执行指令访存
- 立即寻址速度第一，指令直接给出操作数


![Pasted image 20240620195825](https://github.com/user-attachments/assets/23b787a1-e3a5-4771-b29e-9e5121aa7d18)
### 直接寻址
#### 有效地址
EA=A
#### 知识点
【定义】
- 地址码字段给的是操作数的有效位置
- 可以根据这个有效位置去内存中寻找操作数
【特点】
- 直接寻址主要执行取指令访存1次，还有执行指令访存1次


![1718885283447](https://github.com/user-attachments/assets/401cc056-94f4-4ce3-ae10-44027a9a016a)
### 间接寻址
#### 有效地址
EA=(A)
#### 知识点
【定义】

- 地址码字段给的是：操作数有效地址所在存储单元的地址
- 我们需要去这个单元取操作数的地址码，再拿这个地址码去找操作数

【特点】

- 与直接寻址相比：间接寻址执行取指令访存1次，还要执行指令访存2次


![Pasted image 20240620200311](https://github.com/user-attachments/assets/ceddcac0-4c85-4faa-9a01-5e9ce1181378)

![Pasted image 20240620200319](https://github.com/user-attachments/assets/e172b015-daa7-4db6-a84a-d6ee1ea66e8c)
## 访问寄存器的
### 寄存器寻址
#### 有效地址
$EA=R_i$
#### 知识点
【定义】

- 和直接寻址原理一样，只是把访问主存改为访问寄存器

【特点】

- 寄存器寻址主要执行取指令访存1次
- 由于访问的是寄存器因此不需要执行指令访存
- 访问寄存器会比访问主存快得多
- CPU中寄存器不是很多，用很短的编码就可以指定寄存器，能有效地  
    缩短地址段的位数

![Pasted image 20240620200529](https://github.com/user-attachments/assets/2d868bea-17e5-4f9c-a725-7dd331b6da06)


![Pasted image 20240620200955](https://github.com/user-attachments/assets/556fc1bf-f69f-4277-9333-e309a2575e3f)
### 寄存器间接寻址
#### 有效地址
$EA=(R_i)$
#### 知识点
【定义】

- 和访问主存的间接寻址原理相同
- 地址码字段给的是操作数所在的寄存器位置
- 可以根据这个地址去寄存器中找到操作数的有效地址
- 再去内存中寻找操作数

【特点】

- 寄存器间接寻址主要执行取指令访存1次
- 还有一次是寄存器执行指令访存1次


![Pasted image 20240620201112](https://github.com/user-attachments/assets/4bf747fc-4902-494e-bb30-e6c587987def)


![Pasted image 20240620201117](https://github.com/user-attachments/assets/2de79509-b083-4eba-a3d9-0fe9ecd26a9e)
## 转/偏移类寻址
### 基址寻址
#### 有效地址
EA=(BR)+A
#### 知识点
【定义】

- CPU中基址寄存器BR的内容+形式地址A＝有效地址

【特点】

- 基址寄存器不变(作为基地址)，改变的是形式地址A中的值(作为偏移量)
- 不用专门的BR(基址寄存器)也行，可以用通用寄存器
- 原理一样，只不过需要给个编码定位到通用寄存器

【用处】

- 可以扩大寻址范围
- 原先只能寻址A的位数范围内的地址，有了基址寻址的方式
- 可以通过加上一个基地址从而在更大范围的空间内设计程序


![Pasted image 20240620201259](https://github.com/user-attachments/assets/2b476b57-ba9f-45e7-a970-cbb830e61bc7)


![Pasted image 20240620201521](https://github.com/user-attachments/assets/499d78a1-8eb4-4e2b-a238-52c88b13816c)
### 变址寻址
#### 有效地址
EA=(IX)+A
#### 知识点
【定义】

- 通过修改变址值IX从而达到取不同操作数的目的

【特点】

- 变址寄存器的内容可以改变(作为偏移量)，而形式地址A保持不变(作为基地址)
- 变址寻址常用在一些有规律的操作上，比如遍历字符串，遍历数组


![1718885737678 1](https://github.com/user-attachments/assets/3d1e8fad-c9e4-41ef-9178-be9d38cb1810)
### 相对寻址
#### 有效地址
EA=(PC)+A
#### 知识点
【定义】

- 相对寻址是基址寻址的变种，将基址寄存器BR改为程序计数器PC

【特点】

- 地址码中的A是相对于当前指令地址的位移量，用补码表示
- A的位数决定操作数的寻址范围
- 相对寻址有利于程序浮动，广泛用于转移指令和多道程序设计中
- 执行本条指令时，PC已完成加1操作，PC中保存的是下一条指令的地址
- 所以相对寻址的相对地址是以下条指令在内存中首地址为基准位置的偏移量


![1718885985072](https://github.com/user-attachments/assets/382d02a0-727e-4ac7-87ca-316db0712ef0)


## 不常见
### 堆栈寻址(主存特定的)
#### 知识点
【定义】

- 把操作数存放在堆栈中，隐含的使用堆栈指针(SP)作为操作数地址
- SP指针指向栈顶的空单元

【特点】（与正常栈的出入栈顺序相反）

- 入栈，先压入数据，再修改指针
- 出栈，先修改指针，再弹出数据


![1718886082693](https://github.com/user-attachments/assets/c2433e29-0ab0-406b-99f7-1e930b6fd345)

速度⽅⾯：⽴即寻址 > 寄存器寻址 > 直接寻址 > 寄存器间接寻址 > 间接寻址
# 基址寻址和变址寻址的区别
|              |                  |                  |
| ------------ | ---------------- | ---------------- |
|              | 基址寻址             | 变址寻址             |
| 有效地址         | EA=(BR)+A        | EA=(IX)+A        |
| 寄存器内容        | 由操作系统或管理程序确定     | 由用户设定            |
| 程序执行过程中值是否可变 | 不可变              | 可变               |
| 特点           | 多用于多道程序设计和编制浮动程序 | 有利于处理数组问题和编制循环程序 |
# 程序的机器级代码表示
## 相关寄存器
![1724226712826](https://github.com/user-attachments/assets/abd4d608-acde-4b29-a83d-7280468f70fc)
## 汇编指令格式
### AT&T(不考)和Intel格式
![1724226845649](https://github.com/user-attachments/assets/21c599cb-6959-4a52-9ba6-c1af835d9f44)
## 常用指令
```C
<reg> //任意寄存器 <reg16> 16位
<mem> //内存地址
<con> //常数
```

```C
mov <reg> <reg> //数据传送指令
push <reg32> //压入栈，栈增长方向与内存相反，
pop eax //出栈
add <reg> <reg> / sub <reg> <reg> //加，减
inc <reg> / dec <reg> //自增，自减
imul <reg32> <reg32> //有符号数乘法
idiv <reg> //有符号整数除法
and/or/xor //逻辑与/或/异或
not //翻转 0->1,1->0
neg //取负
shl/shr //逻辑左移，右移
jmp //无条件转移
jcondition //有条件转移
cmp/test = sub/and
call/ret //子程序的调用和返回
```
# CISC和RISC
**RISC相比CISC的优点**
- RISC更能充分利用VLSI芯片的面积
- RISC更能提高运算速度
- RISC便于设计，可降低成本，提高可靠性
- RISC有利于编译程序代码优化
- x86处理器属于CISC
## 复杂指令系统计算机CISC
### 特点
- 指令的长度不固定，指令格式多，寻址方式多
- 可以访存的指令不受限制
- 各种指令执行时间相差大，大多需要多个时钟周期才能完成
- 控制器大多数采用微程序控制
### 指令系统
复杂，庞大
### 指令数目
一般大于200条
### 指令字长
不固定
### 可访存指令
不加限制
### 各种指令执行时间
相差较大
### 各种指令执行频度
相差很大
### 通用寄存器数量
较少
### 目标代码
难以用优化编译生成高效的目标代码程序
### 控制方式
绝大数位微程序
### 指令流水线
可以通过一定方式实现
## 精简指令系统计算机RISC
### 特点
- 指令长度固定，指令格式种类少，寻址方式种类少，指令条数少
- 只有Load/Store指令访存，其他指令的操作在寄存器中进行
- CPU中通用寄存器的数量相当多
- 以硬布线控制为主，不用或少用微程序控制
- 有利于实现指令流水线的特点
- 指令格式规整且长度一致
- 指令和数据按边界对齐存放
- 只有Load/Store指令能访问存储器
### 指令系统
简单，精简
### 指令数目
一般小于1000条
### 指令字长
定长
### 可访存指令
LOAD/STORE
### 各种指令执行时间
绝大数在一个周期内完成
### 各种指令使用频度
都比较常用
### 通用寄存器的数量
多
### 目标代码
采用优化的编译程序，生成代码较为高效
### 控制方式
绝大多数为组合逻辑控制
### 指令流水线
必须实现
