# 数制
- 字节是最基本的信息单位【B】
- 位是最小的信息单位【bit】
- 1字节(B)=8位(bit)
## 用二进制编码的好处
- 二进制的运算规则简单
- 制造两个稳态的物理器间较容易
- 便于用逻辑门电路实现算术运算
## 数制的相互转换
![1723633519769](https://github.com/user-attachments/assets/aa4dd266-7f60-41fc-bd28-b6bf64e0c32e)

![1723633580137](https://github.com/user-attachments/assets/01586b19-3b4e-4766-89c6-7093db590558)
# 无符号数
- 寄存器的位数决定了无符号数的表示范围。如8位寄存器，无符号数表示范围为0-255
- 用无符号数表示主存地址
- 8位无符号数的范围：0~255
- 16位无符号数的范围：0~65535
# 有符号数
## 真值和机器数
- 真值：+5
- 机器数：05【0位正，1为负】
## 原码，反码，补码
### 如果正负数都用原码表示，则出现如下情况
-  1的原码00000001，-1的原码10000001，则1+(-1)=00000001+10000001=10000010，结果不是0
-  所以用原码可以表示正数，但是不能表示负数
### 为了表示负数，引入补码【二进制的补数】
- 补码重要法则：(二进制的值取反+1) + (原来的值) = 0
- 【获取-1的补码过程】原码1000001---取反得到反码(符号位不动)---->11111110---加1得到补码---->11111111
- 【获取补码表示的值】补码11111111---求解补码的补码--->原码10000001(对应二进制-1)
### 无符号数和有符号数表示的范围【📢这是补码的表示范围】
- **8位补码表示的整数范围是-128~127【常考】**
- short和unsigned short都是2字节(16位)的变量
- 【有符号数】short表示范围： $-32768\backsim32767(-2^{n-1}\backsim2^{n-1}-1)$
	- 为什么负数比正数多一？
		- 最高位为0的正数，有0~32767共32768个【包括0】
		- 最高位为1的负数，有-1~-32768共32768个【不包括0】
- 【无符号数】unsigned shorty表示范围:0~65535
### 补码的优点
- 0的补码表示唯一，都是0000 0000
- 补码运算规则简单，且符号位可以和数值位一起参加运算
- 补码比原码和反码多表示一个最小负数（-128）
# BCD码
## 8421码 有权码
- 四位数权值分别为8，4，2，1
- 2个8421码加的结果大于9（1001），则需要修正，结果加一个6（0110）
- 如8--->1000, 9---->1001
## 【余3码】无权码
- 在8421的基础上加3（0011）
- 如8---->1011, 9---->1100
## 【2421码】有权码
- 四位数权值分别为2，4，2，1
- 大于等于5的4位二进制中最高位为1，小于5的最高位为0
- 如5--->1011而不是0101
## 移码
- 移码常用来表示浮点数的阶码，只能表示整数
- 整数的补码和移码符号位相反，数值位相同
- $[x]_{移}=2^n+x(2^n>x\geqslant -2^n,机器字长为n+1)$
# 码之间的转换
# 原码->反码->补码
正数：原码，反码，补码全一样

负数：原码->反码：符号位不变其余取反->补码：末尾加一
## 常考的数值
|               | 原码       | 反码       | 补码       | 移码       |
| ------------- | -------- | -------- | -------- | -------- |
| 1             | 00000001 | 00000001 | 00000001 | 10000001 |
| -1            | 10000001 | 11111110 | 11111111 | 01111111 |
| 0             | 00000000 | 00000000 | 00000000 | 10000000 |
| -0【-0等同于-128】 |          |          | 10000000 | 00000000 |
| +127          | 01111111 | 01111111 | 01111111 | 11111111 |
| -128          | 无        | 无        | 10000000 | 00000000 |
# C语言中的整数类型与类型转换
## 有符号数和无符号数的转换
强制类型转换的结果保持位置不变，仅改变了解释这些位的方式
![Pasted image 20240603205517](https://github.com/user-attachments/assets/010f8c9a-7b5f-48b6-b575-30d0f4a6aae5)
## 不同字长整数之间的转换
- 当大字长变量向小字长变量强制类型转换时
	系统把多余的高位部分直接截断，低位直接赋值
- 短字长整数到长字长整数的转换时
	- 要使相应的位值相等，也要对高位部分进行填充
	- 原数位无符号整数，填充0
	- 原数位为有符号整数，进行符号填充
- 📢char为8位无符号整数，转换为int时高位补0即可
![Pasted image 20240603232152](https://github.com/user-attachments/assets/57872dd6-74d7-4bc3-8ce2-d0ffd899ffa8)
