# 数制
- 字节是最基本的信息单位【B】
- 位是最小的信息单位【bit】
- 1字节(B)=8位(bit)
## 用二进制编码的好处
- 二进制的运算规则简单
- 制造两个稳态的物理器间较容易
- 便于用逻辑门电路实现算术运算
## 数制的相互转换
![1723633519769](https://github.com/user-attachments/assets/aa4dd266-7f60-41fc-bd28-b6bf64e0c32e)

![1723633580137](https://github.com/user-attachments/assets/01586b19-3b4e-4766-89c6-7093db590558)
# 无符号数
- 寄存器的位数决定了无符号数的表示范围。如8位寄存器，无符号数表示范围为0-255
- 用无符号数表示主存地址
- 8位无符号数的范围：0~255
- 16位无符号数的范围：0~65535
# 有符号数
## 真值和机器数
- 真值：+5
- 机器数：05【0位正，1为负】
## 原码，反码，补码
### 如果正负数都用原码表示，则出现如下情况
-  1的原码00000001，-1的原码10000001，则1+(-1)=00000001+10000001=10000010，结果不是0
-  所以用原码可以表示正数，但是不能表示负数
### 为了表示负数，引入补码【二进制的补数】
- 补码重要法则：(二进制的值取反+1) + (原来的值) = 0
- 【获取-1的补码过程】原码1000001---取反得到反码(符号位不动)---->11111110---加1得到补码---->11111111
- 【获取补码表示的值】补码11111111---求解补码的补码--->原码10000001(对应二进制-1)
### 无符号数和有符号数表示的范围【📢这是补码的表示范围】
- **8位补码表示的整数范围是-128~127【常考】**
- short和unsigned short都是2字节(16位)的变量
- 【有符号数】short表示范围： $-32768\backsim32767(-2^{n-1}\backsim2^{n-1}-1)$
	- 为什么负数比正数多一？
		- 最高位为0的正数，有0~32767共32768个【包括0】
		- 最高位为1的负数，有-1~-32768共32768个【不包括0】
- 【无符号数】unsigned shorty表示范围:0~65535
### 补码的优点
- 0的补码表示唯一，都是0000 0000
- 补码运算规则简单，且符号位可以和数值位一起参加运算
- 补码比原码和反码多表示一个最小负数（-128）
# BCD码
## 8421码 有权码
- 四位数权值分别为8，4，2，1
- 2个8421码加的结果大于9（1001），则需要修正，结果加一个6（0110）
- 如8--->1000, 9---->1001
## 【余3码】无权码
- 在8421的基础上加3（0011）
- 如8---->1011, 9---->1100
## 【2421码】有权码
- 四位数权值分别为2，4，2，1
- 大于等于5的4位二进制中最高位为1，小于5的最高位为0
- 如5--->1011而不是0101
## 移码
- 移码常用来表示浮点数的阶码，只能表示整数
- 整数的补码和移码符号位相反，数值位相同
- $[x]_{移}=2^n+x(2^n>x\geqslant -2^n,机器字长为n+1)$
# 码之间的转换
# 原码->反码->补码
正数：原码，反码，补码全一样

负数：原码->反码：符号位不变其余取反->补码：末尾加一
## 常考的数值
|               | 原码       | 反码       | 补码       | 移码       |
| ------------- | -------- | -------- | -------- | -------- |
| 1             | 00000001 | 00000001 | 00000001 | 10000001 |
| -1            | 10000001 | 11111110 | 11111111 | 01111111 |
| 0             | 00000000 | 00000000 | 00000000 | 10000000 |
| -0【-0等同于-128】 |          |          | 10000000 | 00000000 |
| +127          | 01111111 | 01111111 | 01111111 | 11111111 |
| -128          | 无        | 无        | 10000000 | 00000000 |
# C语言中的整数类型与类型转换
## 有符号数和无符号数的转换
强制类型转换的结果保持位置不变，仅改变了解释这些位的方式
![Pasted image 20240603205517](https://github.com/user-attachments/assets/010f8c9a-7b5f-48b6-b575-30d0f4a6aae5)
## 不同字长整数之间的转换
- 当大字长变量向小字长变量强制类型转换时
	系统把多余的高位部分直接截断，低位直接赋值
- 短字长整数到长字长整数的转换时
	- 要使相应的位值相等，也要对高位部分进行填充
	- 原数位无符号整数，填充0
	- 原数位为有符号整数，进行符号填充
- 📢char为8位无符号整数，转换为int时高位补0即可
![Pasted image 20240603232152](https://github.com/user-attachments/assets/57872dd6-74d7-4bc3-8ce2-d0ffd899ffa8)
# 基本运算部件
- 补充逻辑运算的知识
- 【逻辑非NOT】
- 【逻辑与AND】只有全为1值才为1
- 【逻辑或OR】有一个为1值就为1
- 【逻辑异或XOR】两个值相同就为1
- 逻辑运算的对象不是数值，因此不会出现进位的情况
- 算术逻辑单元ALU的核心部件是加法器
## 一位全加器[FA]
![Pasted image 20240603202557](https://github.com/user-attachments/assets/9d85f5c5-9304-4d25-8125-ed3ca242f847)

$C_i=A_iB_i+(A_{i}\oplus B_i)C_{i-1}$
- input:加数： $A_i$ , $B_i$ 低位传的进位 $C_{i-1}$
- output:本位和 $S_i$ 像高位进位的 $C_i$
## 串行进位加法器
![Pasted image 20240603203249](https://github.com/user-attachments/assets/076bd5bb-cad4-4bd6-b305-9bc227f68426)
- 串行进位加法器：把n个FA相连得到的n位加法器
- 每级进位直接依赖于前一级的进位，进位信号是逐级形成的
- 最长运算时间主要由进位信号的传递时间决定
## 并行进位加法器
![Pasted image 20240603203338](https://github.com/user-attachments/assets/fe11f6f6-1660-46fc-88f2-f82bf2d91e57)
- 进位信号 $G_i=A_iB_i$ ，进位传递信号 $P_i=A_{i}\oplus B_i$ 
- 进位表达式 $C_i=G_i+PiC_{i-1}$
- $C_i仅与A_i和B_i和最低为C_0有关，相互间进位没有依赖关系$
-  CLA（超前进位部件）是实现上述表达式的部件
- 这种进位方式快速，与位数无关，当位数多时采用全先行进位是不现实的
- 采用并行进位的目的是：提高加法器运算速度
- 通常采用两级或多级先行进位加法器
## 代标志加法器
![Pasted image 20240603204348](https://github.com/user-attachments/assets/2df193e9-c6a2-4381-84a7-f4f8839b93a7)
- 不仅能计算和/差，还能生成相应的标志信息
- 为了加快加法运算的速度，实际电路一定使用多级先行进位方式
- 【OF】溢出标志
- 【SF】符号标志
- 【ZF】零标志，当F=0时，ZF=1
- 【CF】进位/借位标志，$C_{in}=0  CF=C_{out} C_{in}=1 CF=C_{out}$ 取反
- A-B<0时，CF=1；溢出时OF=1
  ## 算数逻辑运算单元ALU
  ![Pasted image 20240603205040](https://github.com/user-attachments/assets/48f061e7-508e-4442-a396-c2b395457813)
- ALU的核心是带标志加法器
- ALU是功能强大的组合逻辑电路，能进行算术运算，逻辑运算，移位操作
- ALUop是操作控制端，决定ALU所执行的处理操作
- ALUop的位数决定了操作的种类，位数为3时，有 $2^3=8$ 种操作
- 在ALUop的控制下，由一个多路选择器MUX选择输出某种操作结果
- MUX是多路选择开关，它从多个输入信号中选择一个送到输出端
# 定点数
- 位数不发生移动的数
- 运算过程中可以不考虑定点数是小数还是整数
## 定点数的运算
### 加减法（常考）
## 补码的加减法运算
- 按二进制运算规则算就可以了
- 符号位和数值位一起参与运算
- 运算结果的高位丢弃
![Pasted image 20240603211002](https://github.com/user-attachments/assets/8e9f8311-b8eb-4da3-8c89-f3da2bc38c1b)
## 运算电路信号解释

| 记忆方法       | 解释                       | 是否有意义         |
|------------|--------------------------|---------------|
| Zero零      | ZF=1表示结果F为0              | 对无符号和有符号数都有意义 |
| Overflow溢出 | OF=1表示带符号整数运算发生溢出        | 对无符号数没有意义     |
| Signal信号   | SF表示结果的符号                | 对无符号数没有意义     |
| Carry进位    | CF表示无符号整数运算时的进位，判断是否发生溢出 | 对于带符号数运算无意义   |

## 溢出判别式
- 一般用异或门来实现溢出判断电路
- 仅当两个符号相同的数相加或两个符  
    号相异的数相减时才可能产生溢出
- 计算时，左边出现溢出，将溢出位丢掉
1、采用一位符号法
- 参与操作的两个数符号相同，结果又与原操作数符号不同，则溢出
2、采用一位符号位根据数据位的进位判断情况判断溢出
- 若符号位的进位和最高数位的进位相同，则没有溢出
3、 采用双符号法/模4补码
- 模4补码有模2补码的所有优点，且更容易检查溢出问题
- 模4补码存储时只需要一个符号位
- 模4补码计算时（在ALU中）需要两个符号位
- 最高位代表真正的符号，低位符号参与移位操作
- 00表示正数，无溢出
- 01表示正溢出
- 10表示负溢出
- 11表示负数，无溢出
# 乘法（不怎么考计算，考概念）
- 乘法操作由累加和右移实现
## 原码一位乘法
- 符号位和数值位是分开求的
- 符号位不参与运算，同号为正，异号为负
- 乘积符号 = 两个数的符号位的异或
- 乘积数值 = 两个数的绝对值相乘的结果
- 积和被乘数采用双符号位
- 【最多进行n次加法运算，n次移位】

![Pasted image 20240603211800](https://github.com/user-attachments/assets/279ffbf0-fa8f-4fa8-a749-44e4ef81aefb)

![Pasted image 20240603211810](https://github.com/user-attachments/assets/e0ea9634-5e73-4787-acc9-1764bef795c7)
## 补码一位乘法【booth运算】
- 是一种有符号数的乘法
- 【最多进行n次移位，n+1次加法运算】
- Booth算法的移位规则


|     |     |               |
| --- | --- | ------------- |
| 高位  | 低位  | 操作            |
| 0   | 0   | 部分积右移一位       |
| 0   | 1   | 部分积加[x]补右移一位  |
| 1   | 0   | 部分积加[-x]补右移一位 |
| 1   | 1   | 部分积右移一位       |

![Pasted image 20240603212519](https://github.com/user-attachments/assets/9d3cf22c-89a6-4506-8da7-00493ee9e739)

![Pasted image 20240603212532](https://github.com/user-attachments/assets/a750ddfd-e91d-4368-9710-254ebcbfb9da)
## 除法（不怎么考计算过程）
- 除法运算由累加和左移（逻辑左移）实现
## 原码除法运算【不恢复余数法】
- 【符号扩展】
	- 正数符号位不变，扩展位填充0
	- 负数原码表示和正数相同，符号位为1
	- 负数补码符号位不变，附加位用1(对于整数)或0(对于小数)进行填充
	- 如16位补码Ox8FA0扩展位32位为OxFFFF 8FA0
	- 如-64位的补码是1100 0000, 则其十六进制为OxFFFF FFC0
- 该方法商符和商值分开进行
- 商符由两个操作数的符号位异或形成
![Pasted image 20240603212835](https://github.com/user-attachments/assets/0f2cbdd1-ea22-47f2-a345-0590adbc8a0d)

![Pasted image 20240603213048](https://github.com/user-attachments/assets/23b103b7-91dc-41c0-bb08-dcb3d3d39995)
## 补码除法运算 【加减交替法】
- 该方法符号位和数值位一起参加运算，商符自然形成
- step1：根据被除数和除数的符号决定做加法还是减法
- step2：上商的原则根据余数和除数的符号位共同决定
	- 同号上商1
	- 异号上商0
- step3：最后一步商置1
![Pasted image 20240603213002](https://github.com/user-attachments/assets/51eb4315-cd89-4410-b480-b04a5cf7f5b0)

![Pasted image 20240603213057](https://github.com/user-attachments/assets/7f032c82-22cc-4dea-a293-1ae44b1ba42d)
# 移位计算
## 算数移位
- 算术移位的对象是有符号数，移位过程中符号位保持不变
- 算术左移情况下，补码左移的前提条件是其原最高有效位与原符号位要相同【如符号位1，最高有效位1，数据不丢失】
- 算术左移实现乘法功能，算术右移实现除法功能

|     | 码制--->添补规则                                         |
| --- | -------------------------------------------------- |
| 正数+ | 原，反，补---->0                                        |
| 负数- | 原码--->0  <br>补码左移--->0  <br>补码右移--->1  <br>反码--->1 |
## 逻辑移位
- 逻辑移位视数为无符号数
- 左移，低位补0
- 右移，高位补0
## 循环移位
【分类】带进位标志CF的循环移位（大循环） + 不带进位标志位CF的循环移位（小循环）  
【主要特点】
- 移出的数位又被移入数据中，而是否带进位则要看是否将进位标志符加入循环位移
- 循环移位适合将数据的低字节数据和高字节数据互换
![Pasted image 20240603215212](https://github.com/user-attachments/assets/d053e66a-c429-4230-b2f2-f43fba9c8b41)
- d中，数据位连同CF一起左移
- 数据的最高位移入CF
- CF则移入数据的最低位
## CF与OF的区别
CF：当成无符号位运算，若溢出则为一 \
OF：当成有符号位运算
