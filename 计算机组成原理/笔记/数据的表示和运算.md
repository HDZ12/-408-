# 数制
- 字节是最基本的信息单位【B】
- 位是最小的信息单位【bit】
- 1字节(B)=8位(bit)
## 用二进制编码的好处
- 二进制的运算规则简单
- 制造两个稳态的物理器间较容易
- 便于用逻辑门电路实现算术运算
## 数制的相互转换
![1723633519769](https://github.com/user-attachments/assets/aa4dd266-7f60-41fc-bd28-b6bf64e0c32e)

![1723633580137](https://github.com/user-attachments/assets/01586b19-3b4e-4766-89c6-7093db590558)
# 无符号数
- 寄存器的位数决定了无符号数的表示范围。如8位寄存器，无符号数表示范围为0-255
- 用无符号数表示主存地址
- 8位无符号数的范围：0~255
- 16位无符号数的范围：0~65535
# 有符号数
## 真值和机器数
- 真值：+5
- 机器数：05【0位正，1为负】
## 原码，反码，补码
### 如果正负数都用原码表示，则出现如下情况
-  1的原码00000001，-1的原码10000001，则1+(-1)=00000001+10000001=10000010，结果不是0
-  所以用原码可以表示正数，但是不能表示负数
### 为了表示负数，引入补码【二进制的补数】
- 补码重要法则：(二进制的值取反+1) + (原来的值) = 0
- 【获取-1的补码过程】原码1000001---取反得到反码(符号位不动)---->11111110---加1得到补码---->11111111
- 【获取补码表示的值】补码11111111---求解补码的补码--->原码10000001(对应二进制-1)
### 无符号数和有符号数表示的范围【📢这是补码的表示范围】
- **8位补码表示的整数范围是-128~127【常考】**
- short和unsigned short都是2字节(16位)的变量
- 【有符号数】short表示范围： $-32768\backsim32767(-2^{n-1}\backsim2^{n-1}-1)$
	- 为什么负数比正数多一？
		- 最高位为0的正数，有0~32767共32768个【包括0】
		- 最高位为1的负数，有-1~-32768共32768个【不包括0】
- 【无符号数】unsigned shorty表示范围:0~65535
### 补码的优点
- 0的补码表示唯一，都是0000 0000
- 补码运算规则简单，且符号位可以和数值位一起参加运算
- 补码比原码和反码多表示一个最小负数（-128）
# BCD码
## 8421码 有权码
- 四位数权值分别为8，4，2，1
- 2个8421码加的结果大于9（1001），则需要修正，结果加一个6（0110）
- 如8--->1000, 9---->1001
## 【余3码】无权码
- 在8421的基础上加3（0011）
- 如8---->1011, 9---->1100
## 【2421码】有权码
- 四位数权值分别为2，4，2，1
- 大于等于5的4位二进制中最高位为1，小于5的最高位为0
- 如5--->1011而不是0101
## 移码
- 移码常用来表示浮点数的阶码，只能表示整数
- 整数的补码和移码符号位相反，数值位相同
- $[x]_{移}=2^n+x(2^n>x\geqslant -2^n,机器字长为n+1)$
# 码之间的转换
# 原码->反码->补码
正数：原码，反码，补码全一样

负数：原码->反码：符号位不变其余取反->补码：末尾加一
## 常考的数值
|               | 原码       | 反码       | 补码       | 移码       |
| ------------- | -------- | -------- | -------- | -------- |
| 1             | 00000001 | 00000001 | 00000001 | 10000001 |
| -1            | 10000001 | 11111110 | 11111111 | 01111111 |
| 0             | 00000000 | 00000000 | 00000000 | 10000000 |
| -0【-0等同于-128】 |          |          | 10000000 | 00000000 |
| +127          | 01111111 | 01111111 | 01111111 | 11111111 |
| -128          | 无        | 无        | 10000000 | 00000000 |
# C语言中的整数类型与类型转换
## 有符号数和无符号数的转换
强制类型转换的结果保持位置不变，仅改变了解释这些位的方式
![Pasted image 20240603205517](https://github.com/user-attachments/assets/010f8c9a-7b5f-48b6-b575-30d0f4a6aae5)
## 不同字长整数之间的转换
- 当大字长变量向小字长变量强制类型转换时
	系统把多余的高位部分直接截断，低位直接赋值
- 短字长整数到长字长整数的转换时
	- 要使相应的位值相等，也要对高位部分进行填充
	- 原数位无符号整数，填充0
	- 原数位为有符号整数，进行符号填充
- 📢char为8位无符号整数，转换为int时高位补0即可
![Pasted image 20240603232152](https://github.com/user-attachments/assets/57872dd6-74d7-4bc3-8ce2-d0ffd899ffa8)
# 基本运算部件
- 补充逻辑运算的知识
- 【逻辑非NOT】
- 【逻辑与AND】只有全为1值才为1
- 【逻辑或OR】有一个为1值就为1
- 【逻辑异或XOR】两个值相同就为1
- 逻辑运算的对象不是数值，因此不会出现进位的情况
- 算术逻辑单元ALU的核心部件是加法器
## 一位全加器[FA]
![Pasted image 20240603202557](https://github.com/user-attachments/assets/9d85f5c5-9304-4d25-8125-ed3ca242f847)

$C_i=A_iB_i+(A_{i}\oplus B_i)C_{i-1}$
- input:加数： $A_i$ , $B_i$ 低位传的进位 $C_{i-1}$
- output:本位和 $S_i$ 像高位进位的 $C_i$
## 串行进位加法器
![Pasted image 20240603203249](https://github.com/user-attachments/assets/076bd5bb-cad4-4bd6-b305-9bc227f68426)
- 串行进位加法器：把n个FA相连得到的n位加法器
- 每级进位直接依赖于前一级的进位，进位信号是逐级形成的
- 最长运算时间主要由进位信号的传递时间决定
## 并行进位加法器
![Pasted image 20240603203338](https://github.com/user-attachments/assets/fe11f6f6-1660-46fc-88f2-f82bf2d91e57)
- 进位信号 $G_i=A_iB_i$ ，进位传递信号 $P_i=A_{i}\oplus B_i$ 
- 进位表达式 $C_i=G_i+PiC_{i-1}$
- $C_i仅与A_i和B_i和最低为C_0有关，相互间进位没有依赖关系$
-  CLA（超前进位部件）是实现上述表达式的部件
- 这种进位方式快速，与位数无关，当位数多时采用全先行进位是不现实的
- 采用并行进位的目的是：提高加法器运算速度
- 通常采用两级或多级先行进位加法器
## 代标志加法器
![Pasted image 20240603204348](https://github.com/user-attachments/assets/2df193e9-c6a2-4381-84a7-f4f8839b93a7)
- 不仅能计算和/差，还能生成相应的标志信息
- 为了加快加法运算的速度，实际电路一定使用多级先行进位方式
- 【OF】溢出标志
- 【SF】符号标志
- 【ZF】零标志，当F=0时，ZF=1
- 【CF】进位/借位标志，$C_{in}=0  CF=C_{out} C_{in}=1 CF=C_{out}$ 取反
- A-B<0时，CF=1；溢出时OF=1
  ## 算数逻辑运算单元ALU
  ![Pasted image 20240603205040](https://github.com/user-attachments/assets/48f061e7-508e-4442-a396-c2b395457813)
- ALU的核心是带标志加法器
- ALU是功能强大的组合逻辑电路，能进行算术运算，逻辑运算，移位操作
- ALUop是操作控制端，决定ALU所执行的处理操作
- ALUop的位数决定了操作的种类，位数为3时，有 $2^3=8$ 种操作
- 在ALUop的控制下，由一个多路选择器MUX选择输出某种操作结果
- MUX是多路选择开关，它从多个输入信号中选择一个送到输出端
# 定点数
- 位数不发生移动的数
- 运算过程中可以不考虑定点数是小数还是整数
## 定点数的运算
### 加减法（常考）
## 补码的加减法运算
- 按二进制运算规则算就可以了
- 符号位和数值位一起参与运算
- 运算结果的高位丢弃
![Pasted image 20240603211002](https://github.com/user-attachments/assets/8e9f8311-b8eb-4da3-8c89-f3da2bc38c1b)
## 运算电路信号解释

| 记忆方法       | 解释                       | 是否有意义         |
|------------|--------------------------|---------------|
| Zero零      | ZF=1表示结果F为0              | 对无符号和有符号数都有意义 |
| Overflow溢出 | OF=1表示带符号整数运算发生溢出        | 对无符号数没有意义     |
| Signal信号   | SF表示结果的符号                | 对无符号数没有意义     |
| Carry进位    | CF表示无符号整数运算时的进位，判断是否发生溢出 | 对于带符号数运算无意义   |

## 溢出判别式
- 一般用异或门来实现溢出判断电路
- 仅当两个符号相同的数相加或两个符  
    号相异的数相减时才可能产生溢出
- 计算时，左边出现溢出，将溢出位丢掉
1、采用一位符号法
- 参与操作的两个数符号相同，结果又与原操作数符号不同，则溢出
2、采用一位符号位根据数据位的进位判断情况判断溢出
- 若符号位的进位和最高数位的进位相同，则没有溢出
3、 采用双符号法/模4补码
- 模4补码有模2补码的所有优点，且更容易检查溢出问题
- 模4补码存储时只需要一个符号位
- 模4补码计算时（在ALU中）需要两个符号位
- 最高位代表真正的符号，低位符号参与移位操作
- 00表示正数，无溢出
- 01表示正溢出
- 10表示负溢出
- 11表示负数，无溢出
# 乘法（不怎么考计算，考概念）
- 乘法操作由累加和右移实现
## 原码一位乘法
- 符号位和数值位是分开求的
- 符号位不参与运算，同号为正，异号为负
- 乘积符号 = 两个数的符号位的异或
- 乘积数值 = 两个数的绝对值相乘的结果
- 积和被乘数采用双符号位
- 【最多进行n次加法运算，n次移位】

![Pasted image 20240603211800](https://github.com/user-attachments/assets/279ffbf0-fa8f-4fa8-a749-44e4ef81aefb)

![Pasted image 20240603211810](https://github.com/user-attachments/assets/e0ea9634-5e73-4787-acc9-1764bef795c7)
## 补码一位乘法【booth运算】
- 是一种有符号数的乘法
- 【最多进行n次移位，n+1次加法运算】
- Booth算法的移位规则


|     |     |               |
| --- | --- | ------------- |
| 高位  | 低位  | 操作            |
| 0   | 0   | 部分积右移一位       |
| 0   | 1   | 部分积加[x]补右移一位  |
| 1   | 0   | 部分积加[-x]补右移一位 |
| 1   | 1   | 部分积右移一位       |

![Pasted image 20240603212519](https://github.com/user-attachments/assets/9d3cf22c-89a6-4506-8da7-00493ee9e739)

![Pasted image 20240603212532](https://github.com/user-attachments/assets/a750ddfd-e91d-4368-9710-254ebcbfb9da)
## 除法（不怎么考计算过程）
- 除法运算由累加和左移（逻辑左移）实现
## 原码除法运算【不恢复余数法】
- 【符号扩展】
	- 正数符号位不变，扩展位填充0
	- 负数原码表示和正数相同，符号位为1
	- 负数补码符号位不变，附加位用1(对于整数)或0(对于小数)进行填充
	- 如16位补码Ox8FA0扩展位32位为OxFFFF 8FA0
	- 如-64位的补码是1100 0000, 则其十六进制为OxFFFF FFC0
- 该方法商符和商值分开进行
- 商符由两个操作数的符号位异或形成
![Pasted image 20240603212835](https://github.com/user-attachments/assets/0f2cbdd1-ea22-47f2-a345-0590adbc8a0d)

![Pasted image 20240603213048](https://github.com/user-attachments/assets/23b103b7-91dc-41c0-bb08-dcb3d3d39995)
## 补码除法运算 【加减交替法】
- 该方法符号位和数值位一起参加运算，商符自然形成
- step1：根据被除数和除数的符号决定做加法还是减法
- step2：上商的原则根据余数和除数的符号位共同决定
	- 同号上商1
	- 异号上商0
- step3：最后一步商置1
![Pasted image 20240603213002](https://github.com/user-attachments/assets/51eb4315-cd89-4410-b480-b04a5cf7f5b0)

![Pasted image 20240603213057](https://github.com/user-attachments/assets/7f032c82-22cc-4dea-a293-1ae44b1ba42d)
# 移位计算
## 算数移位
- 算术移位的对象是有符号数，移位过程中符号位保持不变
- 算术左移情况下，补码左移的前提条件是其原最高有效位与原符号位要相同【如符号位1，最高有效位1，数据不丢失】
- 算术左移实现乘法功能，算术右移实现除法功能

|     | 码制--->添补规则                                         |
| --- | -------------------------------------------------- |
| 正数+ | 原，反，补---->0                                        |
| 负数- | 原码--->0  <br>补码左移--->0  <br>补码右移--->1  <br>反码--->1 |
## 逻辑移位
- 逻辑移位视数为无符号数
- 左移，低位补0
- 右移，高位补0
## 循环移位
【分类】带进位标志CF的循环移位（大循环） + 不带进位标志位CF的循环移位（小循环）  
【主要特点】
- 移出的数位又被移入数据中，而是否带进位则要看是否将进位标志符加入循环位移
- 循环移位适合将数据的低字节数据和高字节数据互换
![Pasted image 20240603215212](https://github.com/user-attachments/assets/d053e66a-c429-4230-b2f2-f43fba9c8b41)
- d中，数据位连同CF一起左移
- 数据的最高位移入CF
- CF则移入数据的最低位
## CF与OF的区别
CF：当成无符号位运算，若溢出则为一 \
OF：当成有符号位运算
# 浮点数（对照十进制的科学计数法）
## 为什么有浮点数
- 由于二进制表示小数会出现问题，如不能用二进制表示0.1，所以设计了浮点数来表示小数。
- 浮点数表示法能以适当的形式将比例因子表示再数据中，让小数点的位置根据需要而浮动。
- 在位数有限的情况下，既扩大了数的表示范围，又保持了数的有效精度
## 什么是浮点数
- 浮点数是指用符号，尾数，基数和指数来表示的小数
- 浮点数有两种【双精度浮点数double, 64位】【单精度浮点数float, 32位】

![Pasted image 20240603215442](https://github.com/user-attachments/assets/3c697657-28eb-4aea-b7ff-728b63edc1f3)
- 基数
	- 二进制基数为2
	- 基数越大，表示范围越大，但是精度越低
- 符号
	- 指使用一个数据位来表示数值的符号，1为负，0为正
- 尾数
	- 尾数的位数反映浮点数的精度
	- 使用正则表达式、将表现形式多样的浮点数统一为一种表达式
	- 规则：基数为2时，将小数点前面的值固定为1；基数为4时，尾数的最高两位不全为0
- 指数(阶码)部分
	- 阶码的位数反映浮点数的表示范围
## 浮点数表示范围
![Pasted image 20240603215626](https://github.com/user-attachments/assets/8abc39c7-5b66-491b-a8f4-26d4fcd8ee33)
- 【正上溢】：大于最大正数
- 【负上溢】：小于绝对值最大负数
- 【正下溢】：0到最小正数之间
- 【负下溢】：0到绝对值最小负数之间
- 通俗来说，上溢就是大于最大数，下溢就是小于最小
## 浮点数举例
阶码，位数均用补码表示，求a,b的真值

| a=001;1.1001; | 001->1,即阶码为1，尾数1.1001对应值 $-\frac{7}{16},a=2^1*-\frac{7}{16}=-\frac{7}{8}$ |
| ------------- | ------------------------------------------------------------------------ |
| b=001;0.01001 | 001->1,即阶码为1，尾数0.01001对应值 $+\frac{9}{32}$                                 |
## 规格化浮点数
## 规格化浮点数
- 规格化：规定尾数的最高数位必须是一个有效值(1)
- 采用规格化浮点数的目的是为了增加数据的表示精度
![Pasted image 20240603232339](https://github.com/user-attachments/assets/0b651288-e63f-4c02-920e-997f39dc8f06)

| 左规  | - 当浮点数运算的结果为非规格化时要进行规格化处理<br>- 将尾数算术左移一位，阶码减1      | $b=2^1*(+0.01001)=2^0*(+0.10010)$                                    |
| --- | -------------------------------------------------- | -------------------------------------------------------------------- |
| 右规  | - 当浮点数运算的结果尾数出现溢出（双符号位为01或10时）<br>- 将尾数算术右移一位，阶码加1 | $a=010;00.1100,b=010;00.1000$$a+b=2^2*(00.1100+00.1000)=2^3*00.1010$ |
## 浮点数加减运算过程【选择题直接用数学知识计算】

| 对阶   | • 目的：使两个操作数的小数点位置对齐      |
|------|--------------------------|
|      | • 对阶操作是把较小的阶码调整到较大的阶码    |
|      | • 阶码增大，尾数右移              |
|      | • 无阶码减小的情况               |
| 尾数求和 | • 对尾数进行加减法               |
| 规格化  | • 规格化浮点数                 |
| 舍入   | • 舍入是浮点数概念，定点数无舍入        |
|      | • 浮点数舍入的情况：对阶或者右规格化      |
|      | • 舍入不一定产生误差（后几位为0时不产生误差） |
| 溢出判断 | • 如果双符号位为01或10时，则溢出      |
| 尾数规格化 | 小数点后第一为和符号位不同 |
# C语言中的浮点数类型
# C语言中的浮点数类型
- 以下转换的范围和精度都从小到大，转换过程没有损失
	- char-->int-->long-->double
	- float-->double
	- int/float-->double【能保留精确值】
	- int-->float【不会发生溢出，int值过大的话可能会发生舍入】
	- double-->float【可能会发送溢出和舍入】
	- float/double-->int【可能会发生溢出和舍入】
 # IEEE 754浮点数的范围【常考选择题】
📢：IEEE 754中尾数用原码表示，阶码用移码表示
![Pasted image 20240603233510](https://github.com/user-attachments/assets/27f6455d-7e85-4b17-a7ee-5d942d59ac2c)

![1717429132189](https://github.com/user-attachments/assets/22752654-fd8b-44d8-b781-a03a55b1dc3b)
# 计算浮点数对应的十进制【例题】【常考选择题】
- 单精度中，最高位为符号位，接着的8位为阶码，偏置值为127，后23位为尾数值【注意，尾数值隐藏了整数部分1】
- 双精度中，最高位为符号位，接着的11位为阶码，偏置值为1023，后52位为为尾数值
# 定点数和浮点数的区别
|         |                 |                   |
| ------- | --------------- | ----------------- |
|         | 定点数             | 浮点数               |
| 数值的表示范围 |                 | 更大                |
| 精度      | 更高              |                   |
| 数的运算    |                 | 更复杂               |
| 溢出问题    | 运算结果超出数的表示范围则溢出 | 运算结果超出数的表示范围不一定溢出 |

# 数据的存储和排列（重点）
## 数据的大端方式和小端方式存储
- 用最低有效字节LSB和最高有效字节MSB分别表示数的低位和高位
- short占2字节=16位
- int，float占4字节=32位
- double占8字节=64位
- 大端方式：按MSB到LSB的顺序存储数据
- 小端方式：按LSB到MSB的顺序存储数据

![Pasted image 20240603205909](https://github.com/user-attachments/assets/3829cd7f-de4f-4924-bfa8-1c699fd18c7a)
- 如小端方式中，按字节编址
- 设int变量i的地址为0800H，i的机器数为01234567H
- 则地址0800H表示的内容为67H
## 数据按边界对齐方式存储
- 边界对齐相对于边界不对齐是一种空间换时间的思想
- 存储字长为32位时，半字是2的整数倍，字地址是4的整数倍，字节大小为8位
- 边界对齐虽然浪费了一些存储空间，但是可以提高取指令和取数的速度
- 边界不对齐可以充分利用存储空间，但是效率不太行

![Pasted image 20240603210300](https://github.com/user-attachments/assets/b69f4bbc-5b66-42f7-9c94-c14b0456a2ef)
